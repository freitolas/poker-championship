<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Curupira's Head Poker 2026 (True God Mode)</title>
  <link rel="icon" type="image/svg+xml" href="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNjQiIGhlaWdodD0iNjQiIHZpZXdCb3g9IjAgMCA2NCA2NCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8Y2lyY2xlIGN4PSIzMiIgY3k9IjMyIiByPSIzMCIgZmlsbD0iI0RDMkI3MSIgc3Ryb2tlPSIjMkUwMDNFIiBzdHJva2Utd2lkdGg9IjQiLz4KICA8dGV4dCB4PSIzMiIgeT0iMzgiIGZvbnQtZmFtaWx5PSJBcmlhbCIgZm9udC1zaXplPSIxOCIgZm9udC13ZWlnaHQ9ImJvbGQiIGZpbGw9IndoaXRlIiB0ZXh0LWFuY2hvcj0ibWlkZGxlIj4yNjwvdGV4dD4KPC9zdmc+">
  <script src="https://accounts.google.com/gsi/client" async defer></script>
  <script src="https://apis.google.com/js/api.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

  <style>
    * { box-sizing: border-box; }
    body {
      margin: 0; padding: 0;
      background: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" opacity="0.1"><circle cx="50" cy="50" r="40" stroke="%23ccc" fill="none"/></svg>'), linear-gradient(135deg, #fff7e1 0%, #ffe0b2 100%);
      background-size: 512px 512px, auto;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      color: #7a4800; display: flex; min-height: 100vh;
    }
    .main-content { flex: 3; padding: 20px; min-width: 500px; overflow-y: auto; position: relative; }
    h1 { text-align: center; color: #e65100; font-size: 2.2rem; margin-bottom: 15px; text-shadow: 2px 2px 4px rgba(0,0,0,0.1); position: relative; }
    
    .game-info { background: linear-gradient(90deg, #ffd740 0%, #ffa726 100%); padding: 15px; border-radius: 10px; text-align: center; color: #d84315; font-weight: 700; margin-bottom: 20px; box-shadow: 0 2px 8px rgba(255, 152, 0, 0.2); }
    .player-setup { background: #fff3e0; padding: 20px; border: 2px solid #ffa726; border-radius: 10px; margin-bottom: 20px; box-shadow: 0 2px 8px rgba(255, 152, 0, 0.1); }
    .major-controls { display: flex; align-items: center; gap: 15px; margin-bottom: 15px; background: #ffe0b2; padding: 10px; border-radius: 6px; border: 1px solid #ffcc80; }
    .player-input-row { display: flex; gap: 12px; margin-bottom: 15px; align-items: center; }
    #playerNameInput, #playerSelect, #tournamentNameSelect { flex: 1; padding: 10px; border: 2px solid #ffa726; border-radius: 6px; font-size: 16px; outline: none; }
    
    button { padding: 10px 16px; border: 2px solid #ffa726; border-radius: 6px; background: #ffb74d; color: #7a4800; font-weight: 700; cursor: pointer; transition: all 0.3s ease; font-size: 14px; }
    button:hover:not(:disabled) { background: #ff9800; color: #fff; transform: translateY(-1px); }
    button:disabled { background: #e0e0e0; color: #999; cursor: not-allowed; border-color: #bdbdbd; }
    .rebuy-btn { background: #f44336 !important; color: white !important; border-color: #d32f2f !important; }
    .addon-btn { background: #2196f3 !important; color: white !important; border-color: #1976d2 !important; }
    .revive-btn { background: #4caf50 !important; color: white !important; border-color: #388e3c !important; }
    
    /* God Mode Controls */
    .stack-ctrl { display: flex; align-items: center; justify-content: center; gap: 5px; }
    .stack-btn { padding: 4px 8px; font-size: 14px; min-width: 30px; cursor: pointer; background: #fff; border: 1px solid #ffa726; }
    .stack-btn:hover { background: #ffe0b2; }
    
    .action-buttons { display: flex; gap: 12px; justify-content: center; margin-top: 15px; flex-wrap: wrap; }
    
    table { width: 100%; border-collapse: collapse; background: #fff3e0; border-radius: 10px; overflow: hidden; box-shadow: 0 4px 12px rgba(255, 152, 0, 0.15); margin-bottom: 20px; }
    th, td { padding: 12px 8px; text-align: center; font-weight: 600; border-bottom: 1px solid #eee; }
    thead { background: linear-gradient(90deg, #ff9800 0%, #fb8c00 100%); color: white; }
    tbody tr:nth-child(odd) { background: #fff9e5; }
    tbody tr.eliminated { background: #ffcdd2 !important; color: #c62828; opacity: 0.9; }
    
    /* Paid Amount Editable */
    .editable-cost { cursor: pointer; border-bottom: 1px dashed #7a4800; }
    .editable-cost:hover { background: #fff; }

    .timer-panel { flex: 1; background: linear-gradient(135deg, #ffecb3 0%, #ffd54f 100%); border-left: 7px solid #ffa726; padding: 25px; display: flex; flex-direction: column; align-items: center; height: 100vh; position: sticky; top: 0; overflow-y: auto; }
    .timer-header { font-size: 2.4rem; font-weight: 900; color: #e65100; margin-bottom: 20px; text-shadow: 2px 2px 4px rgba(0,0,0,0.1); position: relative; }
    .round-info { width: 100%; background: #ffe0b2; border-radius: 12px; padding: 20px; font-size: 1.4rem; font-weight: 700; text-align: center; color: #e65100; margin-bottom: 25px; }
    .time-remaining { font-size: 3.8rem; font-weight: 900; background: #ffd54f; color: #e65100; border-radius: 15px; padding: 20px 35px; box-shadow: 0 4px 12px rgba(255, 152, 0, 0.25); margin: 20px 0 30px; text-align: center; min-width: 200px; font-family: 'Segoe UI', sans-serif; }
    
    .dashboard-tabs { display: flex; border-bottom: 3px solid #ffa726; margin-bottom: 20px; border-radius: 10px 10px 0 0; overflow: hidden; }
    .dashboard-tab { flex: 1; padding: 15px 20px; background: #ffe0b2; color: #e65100; border: none; font-weight: 700; cursor: pointer; border-right: 2px solid #ffa726; }
    .dashboard-tab.active { background: #ff9800; color: white; }
    .dashboard-tab-content { background: #fff3e0; padding: 25px; border-radius: 0 0 10px 10px; min-height: 400px; display: none; }
    .dashboard-tab-content.active { display: block; }
    
    .titles-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px; }
    .title-card { background: linear-gradient(135deg, #fff3e0 0%, #ffecb3 100%); border: 3px solid #ffa726; border-radius: 15px; padding: 20px; text-align: center; }
    .title-card-emoji { font-size: 3rem; display: block; margin-bottom: 10px; }
    .title-card-name { font-size: 1.1rem; font-weight: bold; color: #e65100; margin-bottom: 5px; }
    .title-card-holder { font-size: 1.4rem; font-weight: 900; color: #d84315; margin-bottom: 5px; }
    .title-card-stat { color: #bf360c; font-weight: 600; }
    
    .status-message { background: #e8f5e8; border: 2px solid #4caf50; color: #2e7d32; padding: 12px; border-radius: 8px; margin: 15px 0; text-align: center; font-weight: 600; opacity: 0; transition: opacity 0.3s ease; }
    .status-message.show { opacity: 1; }

    /* Smart Home Modal */
    .smart-btn { position: absolute; top: 20px; right: 20px; background: #2E003E; color: #f7e348; border: 2px solid #dc2b71; font-size: 0.9rem; padding: 8px 12px; cursor: pointer; }
    .sh-modal { display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%,-50%); background: white; border: 3px solid #2E003E; width: 90%; max-width: 500px; padding: 20px; z-index: 2000; border-radius: 10px; box-shadow: 0 10px 30px rgba(0,0,0,0.5); }
    .sh-modal h3 { color: #2E003E; margin-top: 0; }
    .sh-row { margin-bottom: 15px; }
    .sh-row label { display: block; font-weight: bold; margin-bottom: 5px; font-size: 0.9rem; }
    .sh-row input { width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px; }
    .sh-actions { display: flex; justify-content: space-between; align-items: center; margin-top: 20px; border-top: 1px solid #eee; padding-top: 15px; }
    .sh-tools { display: flex; gap: 8px; }
  </style>
</head>
<body>
  <div class="main-content">
    <button class="smart-btn" onclick="openSmartHome()">Smart Home üè†</button>
    <h1>Curupira's Head Poker 2026</h1>
    
    <div class="game-info" id="gameInfoDisplay">
      Buy-in: ¬£5 per stack | 1st: 80% | 2nd: 20% | House Fee: ¬£5
    </div>
    
    <div class="status-message" id="statusMessage"></div>
    
    <div class="player-setup">
      <div class="major-controls">
        <div>
            <label style="font-weight:bold; color:#e65100; margin-right:5px;">Major Mode:</label>
            <input type="checkbox" id="majorToggle" onchange="updateGameSettings()">
        </div>
        <select id="tournamentNameSelect" style="flex:1;" onchange="handleTournamentSelect()">
          <option value="Regular Game">Regular Game</option>
          <option value="The Dry Jan Finishers Cup">The Dry Jan Finishers Cup (Major)</option>
          <option value="The Equinox All-In">The Equinox All-In (Major)</option>
          <option value="Back to School Bounty Championship">Back to School Bounty Championship (Major)</option>
          <option value="The Grand Finale">The Grand Finale (Major)</option>
        </select>
      </div>

      <h3>Add Players</h3>
      <div class="player-input-row">
        <select id="playerSelect">
          <option value="">Select a player...</option>
        </select>
        <input type="text" id="playerNameInput" placeholder="Or enter new player name..." />
        <button onclick="addPlayer()">Add Player</button>
      </div>
      
      <div class="setup-buttons">
        <button onclick="startTournament()" id="startBtn">Start Tournament</button>
        <button onclick="endTournament()" id="endBtn" disabled>End Tournament</button>
        <button onclick="clearPlayers()">Clear All Players</button>
        <button onclick="undoLastAction()" id="undoBtn" disabled>Undo (CTRL+Z)</button>
      </div>
      
      <div id="playerCount">Players: 0 | Prize Pot: ¬£0 | House Fee: ¬£5</div>
      
      <div class="action-buttons">
        <button onclick="signInAndExport()" id="exportBtn">Save Tournament Data</button>
        <button onclick="signInAndLoadDashboard()" id="loadDashboardBtn">Load Championship Dashboard</button>
      </div>
    </div>
    
    <table id="playerTable">
      <thead>
        <tr><th>Player</th><th>Stacks</th><th>Addon?</th><th>Paid</th><th>Status</th><th>Actions</th></tr>
      </thead>
      <tbody id="playerTableBody"></tbody>
    </table>
    
    <div id="dashboardSection" style="display:none; margin-top:20px;">
        <div class="dashboard-tabs">
            <button class="dashboard-tab active" onclick="switchTab('overview')">Overview</button>
            <button class="dashboard-tab" onclick="switchTab('charts')">Charts</button>
            <button class="dashboard-tab" onclick="switchTab('alltime')">All-Time</button>
        </div>
        <div id="tab-overview" class="dashboard-tab-content active">
            <div id="dashboardContent" class="titles-grid"></div>
        </div>
        <div id="tab-charts" class="dashboard-tab-content">
             <canvas id="earningsChart"></canvas>
        </div>
        <div id="tab-alltime" class="dashboard-tab-content">
             <div id="allTimeContent"></div>
        </div>
    </div>
  </div>
  
  <div class="timer-panel">
    <div class="timer-header">ROUND TIMER</div>
    <div id="roundInfo" class="round-info"></div>
    <div id="timeRemaining" class="time-remaining">00:05</div>
    
    <div class="timer-controls">
      <button id="timerStartBtn" onclick="startTimer()">START</button>
      <button id="timerPauseBtn" onclick="pauseTimer()" disabled>PAUSE</button>
      <button id="timerResetBtn" onclick="resetTimer()">RESET</button>
      <button id="timerSkipBtn" onclick="skipRound()">SKIP ROUND</button>
    </div>
    
    <div id="breakNotice" class="break-notice" style="display:none; background:#bbdefb; padding:15px; margin:15px 0; border-radius:10px; color:#0d47a1; font-weight:700; text-align:center;">
      BREAK TIME! - Add-ons available
    </div>
    
    <div class="prize-info">
      <div><strong>Current Prize Pool: ¬£<span id="currentPrizePool">0</span></strong></div>
      <div>1st Place: ¬£<span id="firstPrize">0</span></div>
      <div>2nd Place: ¬£<span id="secondPrize">0</span></div>
    </div>
    
    <audio id="roundAlarm" preload="auto">
      <source src="alarm.mp3" type="audio/mpeg">
    </audio>
  </div>

  <div id="smartHomeModal" class="sh-modal">
    <h3>üè† Smart Home Config (Webhooks)</h3>
    <p style="font-size:0.8rem; color:#666;">Paste IFTTT Webhook URLs here.</p>
    <div class="sh-row">
        <label>Elimination (Red Lights/Sound)</label>
        <input type="text" id="wh-elimination" placeholder="https://maker.ifttt.com/trigger/..." />
    </div>
    <div class="sh-row">
        <label>Round End (Blind Increase)</label>
        <input type="text" id="wh-roundend" placeholder="https://maker.ifttt.com/trigger/..." />
    </div>
    <div class="sh-row">
        <label>Break Time (Music/Chill)</label>
        <input type="text" id="wh-break" placeholder="https://maker.ifttt.com/trigger/..." />
    </div>
    <div class="sh-row">
        <label>Winner (Victory Scene)</label>
        <input type="text" id="wh-winner" placeholder="https://maker.ifttt.com/trigger/..." />
    </div>
    <div class="sh-actions">
        <div class="sh-tools">
            <button onclick="backupSettings()" style="background:#0277bd; color:white; font-size:0.8rem;">Backup üíæ</button>
            <button onclick="restoreSettings()" style="background:#0277bd; color:white; font-size:0.8rem;">Restore üìÇ</button>
        </div>
        <div>
            <button onclick="saveSmartHome()" style="background:#2e7d32; color:white;">Save & Close</button>
            <button onclick="closeSmartHome()" style="background:#666; color:white;">Cancel</button>
        </div>
    </div>
    <input type="file" id="restoreInput" style="display:none" onchange="handleFileSelect(event)" accept=".json">
  </div>
  <div id="sh-overlay" onclick="closeSmartHome()" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.5); z-index:1999;"></div>

  <script>
    // === CONFIGURATION ===
    const CLIENT_ID = '341648594146-a9httcsv8e29vr4ehcup08qlpaak5u8a.apps.googleusercontent.com';
    const SPREADSHEET_ID = '1fZWOlbf95Xqg4AnsEm9ga8x1ENrZ_K_0EEF3sEZGz2Y';
    const SCOPES = 'https://www.googleapis.com/auth/spreadsheets';

    const rounds = [
      { name: "Test Round", sb: 0, bb: 0, duration: 5, isTest: true },
      { name: "Round 1", sb: 5, bb: 10, duration: 20 },
      { name: "Round 2", sb: 10, bb: 20, duration: 20 },
      { name: "Round 3", sb: 20, bb: 40, duration: 20 },
      { name: "Round 4", sb: 40, bb: 80, duration: 20 },
      { name: "Break + Add-On", sb: 0, bb: 0, duration: 30, isBreak: true },
      { name: "Round 5", sb: 50, bb: 100, duration: 20 },
      { name: "Round 6", sb: 100, bb: 200, duration: 20 },
      { name: "Round 7", sb: 200, bb: 400, duration: 20 },
      { name: "Round 8", sb: 400, bb: 800, duration: 20 },
      { name: "Round 9", sb: 1000, bb: 2000, duration: 20 },
      { name: "Round 10", sb: 2000, bb: 4000, duration: 20 },
      { name: "Round 11", sb: 4000, bb: 8000, duration: 20 },
      { name: "Round 12", sb: 8000, bb: 16000, duration: 20 },
      { name: "Round 13", sb: 16000, bb: 32000, duration: 20 },
      { name: "Round 14", sb: 32000, bb: 64000, duration: 20 },
      { name: "Round 15", sb: 64000, bb: 128000, duration: 20 },
      { name: "Round 16", sb: 125000, bb: 250000, duration: 20 },
      { name: "Round 17", sb: 250000, bb: 500000, duration: 20 },
      { name: "Round 18", sb: 500000, bb: 1000000, duration: 20 }
    ];

    const regularPlayers = [
      'Andre', 'Craig', 'Dale', 'Declan', 'Elton', 'Graham', 'Jacques', 'James', 'Lachy', 'Luciano', 'Malzo', 'Matt', 'Nick', 'Rafa', 'Rhys', 'Roberto'
    ].sort();

    // === GLOBAL STATE ===
    let players = [];
    let customPlayers = [];
    let currentRound = 0;
    let timer = null;
    let timeLeft = 0;
    let tournamentStarted = false;
    let tournamentEnded = false;
    let timerRunning = false;
    let googleApiReady = false;
    let tokenClient;
    let historyStack = []; // Deep copy history
    let webhooks = {};

    // === INITIALIZATION ===
    window.onload = function() {
        populatePlayerDropdown();
        updateRoundDisplay();
        updateGameSettings();
        handleClientLoad(); 
        loadSmartHome();
    };

    function handleTournamentSelect() {
        const sel = document.getElementById('tournamentNameSelect').value;
        const majorToggle = document.getElementById('majorToggle');
        if(sel.includes("Major") || sel.includes("Cup") || sel.includes("Finale") || sel.includes("Bounty")) {
            majorToggle.checked = true;
        } else {
            majorToggle.checked = false;
        }
        updateGameSettings();
    }

    function updateGameSettings() {
        const isMajor = document.getElementById('majorToggle').checked;
        const buyIn = isMajor ? 10 : 5;
        document.getElementById('gameInfoDisplay').innerHTML = 
            `MODE: ${isMajor ? 'üèÜ MAJOR (2x Points/Buy-in)' : 'Standard'} | Buy-in: ¬£${buyIn} | 1st: 80% | 2nd: 20% | House Fee: ¬£5`;
        updatePrizeInfo();
    }

    function populatePlayerDropdown() {
      const select = document.getElementById('playerSelect');
      if(!select) return;
      select.innerHTML = '<option value="">Select a player...</option>';
      const all = [...new Set([...regularPlayers, ...customPlayers])].sort();
      all.forEach(p => select.add(new Option(p, p)));
    }

    // === SMART HOME ===
    window.openSmartHome = function() {
        document.getElementById('smartHomeModal').style.display = 'block';
        document.getElementById('sh-overlay').style.display = 'block';
    }
    window.closeSmartHome = function() {
        document.getElementById('smartHomeModal').style.display = 'none';
        document.getElementById('sh-overlay').style.display = 'none';
    }
    window.saveSmartHome = function() {
        webhooks = {
            elim: document.getElementById('wh-elimination').value,
            round: document.getElementById('wh-roundend').value,
            break: document.getElementById('wh-break').value,
            winner: document.getElementById('wh-winner').value
        };
        localStorage.setItem('pokerWebhooks', JSON.stringify(webhooks));
        closeSmartHome();
        showMessage("Smart Home Settings Saved");
    }
    function loadSmartHome() {
        const stored = localStorage.getItem('pokerWebhooks');
        if(stored) {
            webhooks = JSON.parse(stored);
            document.getElementById('wh-elimination').value = webhooks.elim || '';
            document.getElementById('wh-roundend').value = webhooks.round || '';
            document.getElementById('wh-break').value = webhooks.break || '';
            document.getElementById('wh-winner').value = webhooks.winner || '';
        }
    }
    function triggerWebhook(type, v1 = '', v2 = '') {
        const url = webhooks[type];
        if(url) {
            const separator = url.includes('?') ? '&' : '?';
            const finalUrl = `${url}${separator}value1=${encodeURIComponent(v1)}&value2=${encodeURIComponent(v2)}`;
            console.log("Triggering Webhook:", type, "Data:", v1, v2);
            fetch(finalUrl, { mode: 'no-cors' }).catch(e => console.log("Webhook error", e));
        }
    }
    
    // BACKUP AND RESTORE SETTINGS
    window.backupSettings = function() {
        if(!webhooks || Object.keys(webhooks).length === 0) return alert("No settings to backup!");
        const data = JSON.stringify(webhooks);
        const blob = new Blob([data], {type: 'application/json'});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'poker_settings.json';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        showMessage("Settings Downloaded");
    }

    window.restoreSettings = function() {
        document.getElementById('restoreInput').click();
    }

    window.handleFileSelect = function(event) {
        const file = event.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = function(e) {
            try {
                const data = JSON.parse(e.target.result);
                webhooks = data;
                localStorage.setItem('pokerWebhooks', JSON.stringify(webhooks));
                document.getElementById('wh-elimination').value = webhooks.elim || '';
                document.getElementById('wh-roundend').value = webhooks.round || '';
                document.getElementById('wh-break').value = webhooks.break || '';
                document.getElementById('wh-winner').value = webhooks.winner || '';
                alert('Settings Restored Successfully!');
            } catch(err) {
                alert('Invalid settings file.');
            }
        };
        reader.readAsText(file);
    }

    // === RELIABLE UNDO SYSTEM ===
    function saveState() {
        // Deep copy of players array to ensure total isolation
        const state = JSON.stringify(players);
        historyStack.push(state);
        document.getElementById('undoBtn').disabled = false;
        // Limit history to prevent memory issues
        if(historyStack.length > 50) historyStack.shift(); 
    }

    function undoLastAction() {
        if(historyStack.length === 0) return;
        const previousState = historyStack.pop();
        if(historyStack.length === 0) document.getElementById('undoBtn').disabled = true;
        
        players = JSON.parse(previousState);
        renderTable();
        updatePrizeInfo();
        showMessage("Undo Successful");
    }
    
    document.addEventListener('keydown', function(event) {
        if (event.ctrlKey && event.key === 'z') {
            undoLastAction();
        }
    });

    // === PLAYER MANAGEMENT ===
    function addPlayer() {
      const select = document.getElementById('playerSelect');
      const input = document.getElementById('playerNameInput');
      let name = input.value.trim() || select.value;
      
      if (!name) return alert('Please select or enter a name.');
      if (players.find(p => p.name === name)) return alert('Player already added.');
      
      saveState();

      if (!regularPlayers.includes(name) && !customPlayers.includes(name)) {
        customPlayers.push(name);
        populatePlayerDropdown();
      }
      
      players.push({
        name: name,
        stacks: 1,
        totalPaid: document.getElementById('majorToggle').checked ? 10 : 5,
        eliminated: false,
        hasAddon: false,
        eliminationTime: null,
        rebuyEliminations: [] // Track previous deaths (rebuys)
      });
      
      input.value = '';
      select.value = '';
      renderTable();
      updatePrizeInfo();
    }

    function clearPlayers() {
        if(confirm("Clear all players?")) {
            saveState();
            players = [];
            renderTable();
            updatePrizeInfo();
        }
    }

    function renderTable() {
      const tbody = document.getElementById('playerTableBody');
      tbody.innerHTML = '';
      
      const sorted = [...players].sort((a, b) => {
        if (a.eliminated !== b.eliminated) return a.eliminated ? 1 : -1;
        if (a.stacks !== b.stacks) return b.stacks - a.stacks;
        return a.name.localeCompare(b.name);
      });
      
      sorted.forEach(p => {
        const tr = document.createElement('tr');
        if (p.eliminated) tr.classList.add('eliminated');
        
        // GOD MODE: Stacks always editable
        const stackHtml = `
            <div class="stack-ctrl">
                <button class="stack-btn" onclick="updateStack('${p.name}', -1)">-</button>
                <span style="min-width:20px; text-align:center;">${p.stacks}</span>
                <button class="stack-btn" onclick="updateStack('${p.name}', 1)">+</button>
            </div>
        `;

        // GOD MODE: Addon always editable
        const addonHtml = `<input type="checkbox" ${p.hasAddon ? 'checked' : ''} onchange="toggleAddon('${p.name}')">`;

        // GOD MODE: Paid always editable (Prompt)
        const paidHtml = `<span class="editable-cost" onclick="manualEditPaid('${p.name}')">¬£${p.totalPaid}</span>`;

        // Action Buttons: Toggle between Eliminate and Revive
        let actionsHtml = '';
        if (!p.eliminated) {
            actionsHtml += `<button onclick="eliminate('${p.name}')" style="padding:4px 8px; background:#f44336; color:white; border-color:#d32f2f;">Out</button>`;
        } else {
            actionsHtml += `<button class="revive-btn" style="padding:4px 8px;" onclick="revive('${p.name}')">Revive</button>`;
        }

        tr.innerHTML = `
          <td>${p.name}</td>
          <td>${stackHtml}</td>
          <td>${addonHtml}</td>
          <td>${paidHtml}</td>
          <td>${p.eliminated ? 'OUT' : 'Active'}</td>
          <td>${actionsHtml}</td>
        `;
        tbody.appendChild(tr);
      });
      
      updatePrizeInfo();
      document.getElementById('playerCount').innerText = `Players: ${players.length} | Prize Pot: ¬£${calculatePot()} | House Fee: ¬£5`;
    }

    // === GAME ACTIONS (GOD MODE) ===
    function updateStack(name, change) {
        saveState();
        const p = players.find(x => x.name === name);
        if(!p) return;
        
        p.stacks += change;
        if(p.stacks < 0) p.stacks = 0; // Prevent negative stacks
        
        // Adjust cost automatically (can be manually overridden later)
        if(change > 0) {
            const cost = document.getElementById('majorToggle').checked ? 10 : 5;
            p.totalPaid += cost;
        } else {
            const cost = document.getElementById('majorToggle').checked ? 10 : 5;
            p.totalPaid = Math.max(0, p.totalPaid - cost);
        }
        renderTable();
    }

    function toggleAddon(name) {
        saveState();
        const p = players.find(x => x.name === name);
        p.hasAddon = !p.hasAddon;
        const cost = document.getElementById('majorToggle').checked ? 10 : 5;
        if(p.hasAddon) p.totalPaid += cost;
        else p.totalPaid -= cost;
        renderTable();
    }
    
    function manualEditPaid(name) {
        saveState();
        const p = players.find(x => x.name === name);
        const newVal = prompt("Enter new Total Paid amount:", p.totalPaid);
        if(newVal !== null && !isNaN(newVal)) {
            p.totalPaid = parseInt(newVal);
            renderTable();
        } else {
            // Cancelled, undo state save? No, just render.
            // Actually, popping undo here would be cleaner but saving state for nothing is fine.
        }
    }

    function eliminate(name) {
        saveState();
        const p = players.find(x => x.name === name);
        p.eliminated = true;
        p.eliminationTime = Date.now();
        
        const killer = prompt(`Who eliminated ${name}?`);
        p.eliminatedBy = killer || "Unknown";
        
        renderTable();
        
        // Rafa Protocol: Suppress webhook if only 1 player remains (Winner Scene imminent)
        const activeCount = players.filter(pl => !pl.eliminated).length;
        if(activeCount > 1) {
             triggerWebhook('elim', name);
        }
    }

    function revive(name) {
        saveState();
        const p = players.find(x => x.name === name);
        p.eliminated = false;
        p.eliminationTime = null;
        renderTable();
        showMessage(`${name} Resuscitated!`);
    }

    // === TOURNAMENT CONTROL ===
    function startTournament() {
        tournamentStarted = true;
        document.getElementById('startBtn').disabled = true;
        document.getElementById('endBtn').disabled = false;
        showMessage("Tournament Started!");
        startTimer();
    }

    function endTournament() {
        if(!confirm("End Tournament and Finalize Results?")) return;
        tournamentStarted = false;
        tournamentEnded = true;
        pauseTimer();
        document.getElementById('startBtn').disabled = false;
        document.getElementById('endBtn').disabled = true;
        showMessage("Tournament Ended!");
        triggerWebhook('winner');
    }

    function calculatePot() {
        let total = players.reduce((sum, p) => sum + p.totalPaid, 0);
        return Math.max(0, total - 5); // Subtract House Fee
    }

    function updatePrizeInfo() {
        const pot = calculatePot();
        document.getElementById('currentPrizePool').innerText = pot;
        document.getElementById('firstPrize').innerText = (pot * 0.8).toFixed(2);
        document.getElementById('secondPrize').innerText = (pot * 0.2).toFixed(2);
    }

    function showMessage(msg) {
        const el = document.getElementById('statusMessage');
        el.innerText = msg;
        el.classList.add('show');
        setTimeout(() => el.classList.remove('show'), 3000);
    }

    // === TIMER LOGIC ===
    function updateRoundDisplay() {
      const r = rounds[currentRound];
      const nextR = rounds[currentRound + 1];
      const isBreak = r.isBreak;
      
      let html = `<div>${r.name}</div>`;
      if (isBreak) {
        html += `<div style="font-size:0.8em; color:#d84315;">BREAK</div>`;
        document.getElementById('breakNotice').style.display = 'block';
      } else {
        html += `<div style="font-size:1.8rem; margin-top:5px;">${r.sb.toLocaleString()} / ${r.bb.toLocaleString()}</div>`;
        if (nextR) html += `<div style="font-size:0.8rem; color:#777; margin-top:5px;">Next: ${nextR.sb}/${nextR.bb}</div>`;
        document.getElementById('breakNotice').style.display = 'none';
      }
      
      document.getElementById('roundInfo').innerHTML = html;
      
      // Calculate mins/secs
      if (!timerRunning && timeLeft === 0) {
          timeLeft = r.duration * 60;
      }
      displayTime();
    }

    function displayTime() {
        const m = Math.floor(timeLeft / 60);
        const s = timeLeft % 60;
        document.getElementById('timeRemaining').innerText = 
            `${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
    }

    function startTimer() {
        if (timerRunning) return;
        if (timeLeft === 0) updateRoundDisplay(); // Reset if needed
        
        timerRunning = true;
        document.getElementById('timerStartBtn').disabled = true;
        document.getElementById('timerPauseBtn').disabled = false;
        
        timer = setInterval(() => {
            if (timeLeft > 0) {
                timeLeft--;
                displayTime();
            } else {
                roundComplete();
            }
        }, 1000);
    }

    function pauseTimer() {
        clearInterval(timer);
        timerRunning = false;
        document.getElementById('timerStartBtn').disabled = false;
        document.getElementById('timerPauseBtn').disabled = true;
    }

    function resetTimer() {
        pauseTimer();
        timeLeft = rounds[currentRound].duration * 60;
        displayTime();
    }

    function skipRound() {
        pauseTimer();
        currentRound = Math.min(currentRound + 1, rounds.length - 1);
        timeLeft = 0; // Will be set by updateRoundDisplay
        updateRoundDisplay();
        
        // Trigger Webhook immediately on skip
        const r = rounds[currentRound];
        if(r.isBreak) triggerWebhook('break');
        else triggerWebhook('round', r.sb, r.bb);
    }

    function roundComplete() {
        pauseTimer();
        document.getElementById('roundAlarm').play().catch(e=>console.log("Audio play failed"));
        
        // Auto advance
        if (currentRound < rounds.length - 1) {
            currentRound++;
            timeLeft = 0;
            updateRoundDisplay();
            
            // Rafa Protocol: Pass SB (Value1) AND BB (Value2)
            const r = rounds[currentRound];
            if(r.isBreak) {
                triggerWebhook('break');
            } else {
                triggerWebhook('round', r.sb, r.bb);
            }
        } else {
            alert("Tournament Structure Complete!");
        }
    }

    // === GOOGLE SHEETS INTEGRATION ===
    function handleClientLoad() {
      tokenClient = google.accounts.oauth2.initTokenClient({
        client_id: CLIENT_ID,
        scope: SCOPES,
        callback: (tokenResponse) => {
          if (tokenResponse && tokenResponse.access_token) {
            googleApiReady = true;
            // Depending on which button triggered auth, run that action
            if(window.pendingAction === 'export') exportData();
            if(window.pendingAction === 'dashboard') loadDashboard();
          }
        },
      });
      
      // Load GAPI for spreadsheets
      gapi.load('client', () => {
          gapi.client.init({
              discoveryDocs: ["https://sheets.googleapis.com/$discovery/rest?version=v4"],
          });
      });
    }

    function signInAndExport() {
        window.pendingAction = 'export';
        if(googleApiReady && gapi.client.sheets) exportData();
        else tokenClient.requestAccessToken();
    }

    function signInAndLoadDashboard() {
        window.pendingAction = 'dashboard';
        if(googleApiReady && gapi.client.sheets) loadDashboard();
        else tokenClient.requestAccessToken();
    }

    async function exportData() {
        if(!tournamentEnded && !confirm("Tournament hasn't officially ended. Save anyway?")) return;
        
        const timestamp = new Date().toISOString().replace(/T/, ' ').replace(/\..+/, '');
        const dateStr = timestamp.split(' ')[0];
        const timeStr = timestamp.split(' ')[1];
        const tournId = `${dateStr}_${timeStr.replace(/:/g,'-')}`;
        const isMajor = document.getElementById('majorToggle').checked;
        const tournamentName = document.getElementById('tournamentNameSelect').value;

        // Prepare Rows: One per elimination/finish
        let rows = [];
        
        let activePlayers = players.filter(p => !p.eliminated);
        let eliminatedPlayers = players.filter(p => p.eliminated).sort((a,b) => b.eliminationTime - a.eliminationTime);
        
        const totalP = players.length;
        
        // 1. Process Rebuys (FinishPosition = 0)
        players.forEach(p => {
            if(p.rebuyEliminations && p.rebuyEliminations.length > 0) {
                p.rebuyEliminations.forEach(rebuy => {
                    rows.push([
                        dateStr, timeStr, tournId, p.name, 
                        0, // FinishPos 0 for rebuy
                        totalP, 
                        0, 0, // Paid/Earned 0 here
                        0, 0, 0,
                        rebuy.eliminatedBy,
                        tournamentName,
                        isMajor
                    ]);
                });
            }
        });

        // 2. Process Final Results
        let finalRankings = [];
        
        // Add Winner(s)
        activePlayers.forEach(p => finalRankings.push({ player: p, rank: 1 }));
        
        // Add Eliminated
        let currentRank = activePlayers.length + 1;
        eliminatedPlayers.forEach(p => {
            finalRankings.push({ player: p, rank: currentRank });
            currentRank++;
        });

        // Build Rows
        finalRankings.forEach(item => {
            const p = item.player;
            const rank = item.rank;
            
            // Calculate Earnings
            let prize = 0;
            const pot = calculatePot();
            if(rank === 1) prize = activePlayers.length === 1 ? pot * 0.8 : (pot / activePlayers.length); 
            if(activePlayers.length === 1 && rank === 1) prize = pot * 0.8;
            if(rank === 2) prize = pot * 0.2;
            
            // ROI
            const earnings = prize;
            const roi = p.totalPaid > 0 ? ((earnings - p.totalPaid)/p.totalPaid)*100 : 0;
            
            rows.push([
                dateStr, timeStr, tournId, p.name,
                rank,
                totalP,
                p.totalPaid,
                earnings,
                p.stacks - 1, // Rebuys approx
                p.hasAddon ? 1 : 0,
                roi.toFixed(1),
                p.eliminated ? p.eliminatedBy : 'N/A',
                tournamentName,
                isMajor
            ]);
        });

        const resource = { values: rows };
        
        try {
            await gapi.client.sheets.spreadsheets.values.append({
                spreadsheetId: SPREADSHEET_ID,
                range: 'PlayerResults!A:N', // Adjust sheet name if needed
                valueInputOption: 'USER_ENTERED',
                resource: resource,
            });
            alert("Data Exported to Google Sheets!");
        } catch (err) {
            console.error("Export error", err);
            alert("Error exporting data. Check console.");
        }
    }

    // === DASHBOARD LOGIC (Rows Fixed + 2025 Separation) ===
    async function loadDashboard() {
        document.getElementById('dashboardSection').style.display = 'block';
        window.scrollTo(0, document.body.scrollHeight);
        
        try {
            // Fetch ALL data
            const res = await gapi.client.sheets.spreadsheets.values.get({
                spreadsheetId: SPREADSHEET_ID,
                range: 'PlayerResults!A2:N', // Skip header
            });
            
            const allRows = res.result.values || [];
            if(allRows.length === 0) {
                document.getElementById('dashboardContent').innerHTML = "No data found.";
                return;
            }

            // Filter for 2026 for specific tabs
            const rows2026 = allRows.filter(r => r[0].startsWith('2026'));

            // === CALCULATIONS ===
            const stats2026 = calculate2026Points(rows2026);
            const detail2026 = calculateDetailedStats(rows2026);
            
            // All Time now calculates from EVERYTHING in the sheet (2025+2026)
            // assuming user might eventually paste 2025 back or just wants current sheet stats
            const allTime = calculateAllTime(allRows); 
            const titles = calculateTitles(calculateDetailedStats(rows2026, true));

            // Render Overview (2026 Data)
            const overviewHtml = `
                <div class="title-card">
                    <span class="title-card-emoji">üë•</span>
                    <div class="title-card-name">Fixture (2026)</div>
                    <div class="title-card-holder">${stats2026.length} Players</div>
                </div>
                ${renderTitles(titles)}
            `;
            document.getElementById('dashboardContent').innerHTML = overviewHtml;
            document.getElementById('p2026-leaderboard').innerHTML = render2026Leaderboard(stats2026);
            document.getElementById('allTimeContent').innerHTML = renderAllTime(allTime);
            
            // Render Chart
            renderChart(stats2026);

        } catch(err) {
            console.error(err);
            alert("Error loading dashboard data.");
        }
    }

    function calculate2026Points(rows) {
        const tournaments = {}; 
        const stats = {};
        
        rows.forEach(r => {
            const [d, t, tid, name, rankStr, f, paid, earn, rebuy, addon, roi, killer, tname, isMaj] = r;
            const isMajor = isMaj === 'TRUE';
            const rank = parseInt(rankStr);
            const multiplier = isMajor ? 2 : 1;

            if(!tournaments[tid]) tournaments[tid] = { kills: {}, isMajor: isMajor, ranks: {} };
            if (rank > 0) tournaments[tid].ranks[name] = rank;
            
            if(killer && killer !== 'N/A') {
                tournaments[tid].kills[killer] = (tournaments[tid].kills[killer] || 0) + 1;
            }

            // Points logic: Only for rank > 0
            if (rank > 0) {
                if(!stats[name]) stats[name] = { points:0, wins:0, seconds:0, thirds:0, att:0, killerWins:0 };
                
                stats[name].att++;
                stats[name].points += (1 * multiplier); 

                if(rank === 1) { stats[name].points += (10 * multiplier); stats[name].wins++; }
                if(rank === 2) { stats[name].points += (7 * multiplier); stats[name].seconds++; }
                if(rank === 3) { stats[name].points += (4 * multiplier); stats[name].thirds++; }
            }
        });

        // Killer Bonus Logic
        Object.values(tournaments).forEach(t => {
            const mult = t.isMajor ? 2 : 1;
            const eligibleKillers = [];
            
            Object.keys(t.kills).forEach(k => {
                const rk = t.ranks[k];
                if(rk && rk >= 3) eligibleKillers.push({ name: k, count: t.kills[k] });
            });
            
            if(eligibleKillers.length > 0) {
                eligibleKillers.sort((a,b) => b.count - a.count);
                const max = eligibleKillers[0].count;
                eligibleKillers.forEach(ek => {
                    if(ek.count === max && stats[ek.name]) {
                        stats[ek.name].points += (2 * mult);
                        stats[ek.name].killerWins++;
                    }
                });
            }
        });
        return Object.entries(stats).sort((a,b) => b[1].points - a[1].points);
    }

    function calculateDetailedStats(rows, returnRaw = false) {
        const s = {};
        rows.forEach(r => {
            const [d,t,id,name,rankStr,fieldStr,paid,earn,rebuy,addon,roi,killer] = r;
            const rank = parseInt(rankStr);
            const field = parseInt(fieldStr);
            const cost = parseFloat(paid)||0;
            const earnings = parseFloat(earn)||0; 
            
            if(!s[name]) s[name] = { 
                played:0, wins:0, sec:0, third:0, 
                rebuys:0, addons:0, kills:0, deaths:0, 
                firstOuts:0, totalProfit:0 
            };
            
            if (rank > 0) {
                s[name].played++;
                s[name].rebuys += parseInt(rebuy)||0;
                s[name].addons += parseInt(addon)||0;
                s[name].totalProfit += (earnings - cost);
                
                if(rank === 1) s[name].wins++;
                if(rank === 2) s[name].sec++;
                if(rank === 3) s[name].third++;
                if(rank > 1) s[name].deaths++;
                if(rank === field) s[name].firstOuts++; 
            }
            
            if(killer && killer !== 'N/A') {
                if(!s[killer]) s[killer] = { played:0, wins:0, sec:0, third:0, rebuys:0, addons:0, kills:0, deaths:0, firstOuts:0, totalProfit:0 };
                s[killer].kills++;
            }
        });
        
        if (returnRaw) return s;

        return Object.entries(s).map(([name, d]) => {
            d.winRate = d.played > 0 ? ((d.wins / d.played)*100).toFixed(0) + '%' : '0%';
            d.cashRate = d.played > 0 ? (((d.wins + d.sec)/d.played)*100).toFixed(0) + '%' : '0%';
            return [name, d];
        });
    }

    function calculateAllTime(rows) {
        const s = {};
        rows.forEach(r => {
            const name = r[3];
            const rank = parseInt(r[4]);
            if(!s[name]) s[name] = { played:0, wins:0, sec:0, third:0, kills:0 };
            
            if (rank > 0) {
                s[name].played++;
                if(rank===1) s[name].wins++;
                if(rank===2) s[name].sec++;
                if(rank===3) s[name].third++;
            }

            if(r[11] && r[11]!=='N/A') {
                if(!s[r[11]]) s[r[11]] = { played:0, wins:0, sec:0, third:0, kills:0 };
                s[r[11]].kills++;
            }
        });
        return Object.entries(s).sort((a,b) => b[1].wins - a[1].wins);
    }
    
    function calculateTitles(statsObj) {
        let t = {
            champion: {n:'-', v:0},
            runnerup: {n:'-', v:0},
            musk: {n:'-', v:0},
            fixture: {n:'-', v:0},
            killer: {n:'-', v:0},
            early: {n:'-', v:0},
            phoenix: {n:'-', v:0},
            bubble: {n:'-', v:0}
        };
        
        Object.entries(statsObj).forEach(([n, d]) => {
            if(d.wins > t.champion.v) t.champion = {n:n, v:d.wins};
            if(d.sec > t.runnerup.v) t.runnerup = {n:n, v:d.sec};
            if(d.totalProfit > t.musk.v) t.musk = {n:n, v:d.totalProfit};
            if(d.played > t.fixture.v) t.fixture = {n:n, v:d.played};
            if(d.kills > t.killer.v) t.killer = {n:n, v:d.kills};
            if(d.firstOuts > t.early.v) t.early = {n:n, v:d.firstOuts};
            if(d.rebuys > t.phoenix.v) t.phoenix = {n:n, v:d.rebuys};
            if(d.third > t.bubble.v) t.bubble = {n:n, v:d.third};
        });
        return t;
    }

    function render2026Leaderboard(data) {
        // Needs a dedicated container in tab-overview if you want it there, 
        // OR simpler: put it in Overview tab.
        // For simplicity, I'm just returning text logic here.
        // But dashboard logic above might need adjustment.
        // Let's attach this to the Overview
        return `<table><thead><tr><th>Rank</th><th>Player</th><th>Points</th><th>1st</th><th>2nd</th><th>3rd</th><th>Att</th></tr></thead><tbody>${data.map((p, i) => `<tr><td>#${i+1}</td><td><strong>${p[0]}</strong></td><td style="color:#d84315; font-weight:bold;">${p[1].points}</td><td>${p[1].wins}</td><td>${p[1].seconds}</td><td>${p[1].thirds}</td><td>${p[1].att}</td></tr>`).join('')}</tbody></table>`;
    }

    function renderTitles(t) {
        return `
        <div class="titles-grid" style="margin-top:20px;">
            <div class="title-card"><span class="title-card-emoji">üëë</span><div class="title-card-name">The Champion</div><div class="title-card-holder">${t.champion.n}</div><div class="title-card-stat">${t.champion.v} Wins</div></div>
            <div class="title-card"><span class="title-card-emoji">üí∞</span><div class="title-card-name">Elon Musk</div><div class="title-card-holder">${t.musk.n}</div><div class="title-card-stat">¬£${t.musk.v.toFixed(0)}</div></div>
            <div class="title-card"><span class="title-card-emoji">üíÄ</span><div class="title-card-name">The Killer</div><div class="title-card-holder">${t.killer.n}</div><div class="title-card-stat">${t.killer.v} Kills</div></div>
        </div>
        <div style="margin-top:20px; font-weight:bold; color:#e65100;">Current Leaderboard (2026)</div>
        <div id="p2026-leaderboard"></div>
        `;
    }

    function renderAllTime(data) {
        return `<table><thead><tr><th>Rank</th><th>Player</th><th>ü•á Wins</th><th>ü•à 2nd</th><th>3rd</th><th>Games</th><th>Kills</th></tr></thead><tbody>
        ${data.map((p,i) => `<tr><td>${i+1}</td><td>${p[0]}</td><td>${p[1].wins}</td><td>${p[1].sec}</td><td>${p[1].third}</td><td>${p[1].played}</td><td>${p[1].kills}</td></tr>`).join('')}</tbody></table>`;
    }

    function renderChart(data) {
        const ctx = document.getElementById('earningsChart').getContext('2d');
        const sorted = data.slice(0, 10);
        
        if(window.myChart) window.myChart.destroy();
        
        window.myChart = new Chart(ctx, {
            type: 'bar',
            data: {
                labels: sorted.map(x => x[0]),
                datasets: [{
                    label: '2026 Points',
                    data: sorted.map(x => x[1].points),
                    backgroundColor: 'rgba(255, 152, 0, 0.6)',
                    borderColor: 'rgba(230, 81, 0, 1)',
                    borderWidth: 1
                }]
            },
            options: { responsive: true, scales: { y: { beginAtZero: true } } }
        });
    }
    
    function switchTab(tabName) {
        document.querySelectorAll('.dashboard-tab').forEach(t => t.classList.remove('active'));
        document.querySelectorAll('.dashboard-tab-content').forEach(c => c.classList.remove('active'));
        
        event.target.classList.add('active');
        document.getElementById(`tab-${tabName}`).classList.add('active');
    }

  </script>
</body>
</html>