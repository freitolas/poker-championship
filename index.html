<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Texas Hold'em Championship Manager</title>
  <script src="https://accounts.google.com/gsi/client" async defer></script>
  <script src="https://apis.google.com/js/api.js"></script>
  <style>
    * {
      box-sizing: border-box;
    }
    
    body {
      margin: 0;
      padding: 0;
      background: linear-gradient(135deg, #fff7e1 0%, #ffe0b2 100%);
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      color: #7a4800;
      display: flex;
      min-height: 100vh;
    }
    
    .main-content {
      flex: 3;
      padding: 20px;
      min-width: 500px;
      overflow-y: auto;
    }
    
    h1 {
      text-align: center;
      color: #e65100;
      font-size: 2.2rem;
      margin-bottom: 15px;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
    }
    
    .game-info {
      background: linear-gradient(90deg, #ffd740 0%, #ffa726 100%);
      padding: 15px;
      border-radius: 10px;
      text-align: center;
      color: #d84315;
      font-weight: 700;
      margin-bottom: 20px;
      box-shadow: 0 2px 8px rgba(255, 152, 0, 0.2);
    }
    
    .player-setup {
      background: #fff3e0;
      padding: 20px;
      border: 2px solid #ffa726;
      border-radius: 10px;
      margin-bottom: 20px;
      box-shadow: 0 2px 8px rgba(255, 152, 0, 0.1);
    }
    
    .player-setup h3 {
      margin-top: 0;
      color: #e65100;
      font-size: 1.4rem;
    }
    
    .player-input-row {
      display: flex;
      gap: 12px;
      margin-bottom: 15px;
      align-items: center;
    }
    
    #playerNameInput, #playerSelect {
      flex: 1;
      padding: 10px;
      border: 2px solid #ffa726;
      border-radius: 6px;
      font-size: 16px;
      outline: none;
      transition: border-color 0.3s;
    }
    
    #playerNameInput:focus, #playerSelect:focus {
      border-color: #ff9800;
      box-shadow: 0 0 0 3px rgba(255, 152, 0, 0.2);
    }
    
    .setup-buttons {
      display: flex;
      gap: 12px;
      margin: 15px 0;
      flex-wrap: wrap;
    }
    
    button {
      padding: 10px 16px;
      border: 2px solid #ffa726;
      border-radius: 6px;
      background: #ffb74d;
      color: #7a4800;
      font-weight: 700;
      cursor: pointer;
      transition: all 0.3s ease;
      font-size: 14px;
    }
    
    button:hover:not(:disabled) {
      background: #ff9800;
      color: #fff;
      transform: translateY(-1px);
      box-shadow: 0 3px 8px rgba(255, 152, 0, 0.3);
    }
    
    button:disabled {
      background: #e0e0e0;
      color: #9e9e9e;
      cursor: not-allowed;
      border-color: #bdbdbd;
      transform: none;
      box-shadow: none;
    }
    
    .rebuy-btn {
      background: #f44336 !important;
      color: white !important;
      border-color: #d32f2f !important;
    }
    
    .rebuy-btn:hover:not(:disabled) {
      background: #d32f2f !important;
    }
    
    .addon-btn {
      background: #2196f3 !important;
      color: white !important;
      border-color: #1976d2 !important;
    }
    
    .addon-btn:hover:not(:disabled) {
      background: #1976d2 !important;
    }
    
    .action-buttons {
      display: flex;
      gap: 12px;
      justify-content: center;
      margin-top: 15px;
      flex-wrap: wrap;
    }
    
    #playerCount {
      text-align: center;
      font-weight: 600;
      color: #e65100;
      margin: 10px 0;
      font-size: 1.1rem;
    }
    
    table {
      width: 100%;
      border-collapse: collapse;
      background: #fff3e0;
      border-radius: 10px;
      overflow: hidden;
      box-shadow: 0 4px 12px rgba(255, 152, 0, 0.15);
      margin-bottom: 20px;
    }
    
    th, td {
      padding: 12px 8px;
      text-align: center;
      font-weight: 600;
    }
    
    thead {
      background: linear-gradient(90deg, #ff9800 0%, #fb8c00 100%);
      color: white;
    }
    
    tbody tr:nth-child(odd) {
      background: #fff9e5;
    }
    
    tbody tr:nth-child(even) {
      background: #fff3e0;
    }
    
    tbody tr.eliminated {
      background: #ffcdd2 !important;
      color: #c62828;
      opacity: 0.8;
    }
    
    .timer-panel {
      flex: 1;
      background: linear-gradient(135deg, #ffecb3 0%, #ffd54f 100%);
      border-left: 7px solid #ffa726;
      box-shadow: -2px 0 14px rgba(255, 152, 0, 0.13);
      padding: 25px;
      display: flex;
      flex-direction: column;
      align-items: center;
      height: 100vh;
      position: sticky;
      top: 0;
      overflow-y: auto;
    }
    
    .timer-header {
      font-size: 2.4rem;
      font-weight: 900;
      color: #e65100;
      margin-bottom: 20px;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
    }
    
    .round-info {
      width: 100%;
      background: #ffe0b2;
      border-radius: 12px;
      padding: 20px;
      font-size: 1.4rem;
      font-weight: 700;
      text-align: center;
      color: #e65100;
      margin-bottom: 25px;
      box-shadow: 0 2px 8px rgba(255, 152, 0, 0.2);
    }
    
    .blind-display {
      background: #ffd54f;
      padding: 10px 16px;
      border-radius: 8px;
      font-size: 1.6rem;
      color: #e65100;
      margin: 10px 0;
      font-weight: 800;
    }
    
    .time-remaining {
      font-size: 3.8rem;
      font-weight: 900;
      background: #ffd54f;
      color: #e65100;
      border-radius: 15px;
      padding: 20px 35px;
      box-shadow: 0 4px 12px rgba(255, 152, 0, 0.25);
      margin: 20px 0 30px;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
      min-width: 200px;
      text-align: center;
    }
    
    .timer-controls {
      display: flex;
      gap: 12px;
      margin-bottom: 25px;
      flex-wrap: wrap;
      justify-content: center;
    }
    
    .timer-controls button {
      min-width: 80px;
    }
    
    .break-notice, .final-stage {
      display: none;
      width: 100%;
      padding: 15px;
      border-radius: 10px;
      text-align: center;
      font-weight: 700;
      margin: 15px 0;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }
    
    .break-notice {
      background: #bbdefb;
      color: #0d47a1;
      border: 2px solid #2196f3;
    }
    
    .final-stage {
      background: #ffecb3;
      color: #e65100;
      border: 2px solid #ffa726;
    }
    
    .prize-info {
      background: #fff3e0;
      padding: 20px;
      border-radius: 10px;
      text-align: center;
      font-weight: 600;
      color: #e65100;
      margin-top: 20px;
      width: 100%;
      box-shadow: 0 2px 8px rgba(255, 152, 0, 0.2);
    }
    
    .prize-info div {
      margin: 8px 0;
      font-size: 1.1rem;
    }
    
    .prize-info div:first-child {
      font-size: 1.3rem;
      font-weight: 800;
    }
    
    .charts-section {
      margin-top: 30px;
    }
    
    .charts-section h3 {
      color: #e65100;
      font-size: 1.8rem;
      text-align: center;
      margin-bottom: 20px;
    }
    
    /* Dashboard Tab Styles */
    .dashboard-tabs {
      display: flex;
      border-bottom: 3px solid #ffa726;
      margin-bottom: 20px;
      background: #fff3e0;
      border-radius: 10px 10px 0 0;
      overflow: hidden;
    }
    
    .dashboard-tab {
      flex: 1;
      padding: 15px 20px;
      background: #ffe0b2;
      color: #e65100;
      border: none;
      font-weight: 700;
      font-size: 1.1rem;
      cursor: pointer;
      transition: all 0.3s ease;
      border-right: 2px solid #ffa726;
    }
    
    .dashboard-tab:last-child {
      border-right: none;
    }
    
    .dashboard-tab:hover {
      background: #ffcc02;
      transform: translateY(-2px);
    }
    
    .dashboard-tab.active {
      background: #ff9800;
      color: white;
      transform: translateY(-2px);
      box-shadow: 0 2px 8px rgba(255, 152, 0, 0.4);
    }
    
    .dashboard-tab-content {
      background: #fff3e0;
      padding: 25px;
      border-radius: 0 0 10px 10px;
      min-height: 400px;
      box-shadow: 0 4px 12px rgba(255, 152, 0, 0.15);
    }
    
    .dashboard-tab-panel {
      display: none;
    }
    
    .dashboard-tab-panel.active {
      display: block;
    }
    
    /* Title Cards Styles */
    .titles-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
      gap: 20px;
      margin-top: 20px;
    }
    
    .title-card {
      background: linear-gradient(135deg, #fff3e0 0%, #ffecb3 100%);
      border: 3px solid #ffa726;
      border-radius: 15px;
      padding: 20px;
      text-align: center;
      box-shadow: 0 4px 12px rgba(255, 152, 0, 0.2);
      transition: transform 0.3s ease;
    }
    
    .title-card:hover {
      transform: translateY(-5px);
      box-shadow: 0 8px 20px rgba(255, 152, 0, 0.3);
    }
    
    .title-card-emoji {
      font-size: 3rem;
      margin-bottom: 10px;
      display: block;
    }
    
    .title-card-name {
      font-size: 1.3rem;
      font-weight: bold;
      color: #e65100;
      margin-bottom: 8px;
    }
    
    .title-card-holder {
      font-size: 1.8rem;
      font-weight: 900;
      color: #d84315;
      margin-bottom: 8px;
    }
    
    .title-card-stat {
      font-size: 1.1rem;
      color: #bf360c;
      font-weight: 600;
    }
    
    .status-message, .error-message {
      background: #e8f5e8;
      border: 2px solid #4caf50;
      color: #2e7d32;
      padding: 12px;
      border-radius: 8px;
      margin: 15px 0;
      text-align: center;
      font-weight: 600;
      height: 20px;
      min-height: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0;
      transition: opacity 0.3s ease;
    }
    
    .error-message {
      background: #ffebee;
      border: 2px solid #f44336;
      color: #c62828;
    }
    
    .status-message.show, .error-message.show {
      opacity: 1;
    }
    
    @media (max-width: 768px) {
      body {
        flex-direction: column;
      }
      
      .main-content {
        min-width: auto;
      }
      
      .timer-panel {
        height: auto;
        position: relative;
      }
      
      .timer-header {
        font-size: 2rem;
      }
      
      .time-remaining {
        font-size: 3rem;
      }
    }
  </style>
</head>
<body>
  <div class="main-content">
    <h1>Texas Hold'em Championship Manager</h1>
    
    <div class="game-info">
      Buy-in: ¬£5 per stack | 1st: 80% | 2nd: 20% | House Fee: ¬£5 (¬£10 if pot > ¬£100)
    </div>
    
    <div class="status-message" id="statusMessage"></div>
    <div class="error-message" id="errorMessage"></div>
    
    <div class="player-setup">
      <h3>Add Players</h3>
      <div class="player-input-row">
        <select id="playerSelect">
          <option value="">Select a player...</option>
        </select>
        <input type="text" id="playerNameInput" placeholder="Or enter new player name..." />
        <button onclick="addPlayer()">Add Player</button>
      </div>
      
      <div class="setup-buttons">
        <button onclick="startTournament()" id="startBtn">Start Tournament</button>
        <button onclick="endTournament()" id="endBtn" disabled>End Tournament</button>
        <button onclick="clearPlayers()">Clear All Players</button>
        <button onclick="undoLastAction()" id="undoBtn" disabled>Undo</button>
      </div>
      
      <div id="playerCount">Players: 0 | Prize Pot: ¬£0 | House Fee: ¬£5</div>
      
      <div class="action-buttons">
        <button onclick="signInAndExport()" id="exportBtn" disabled>Save Tournament Data</button>
        <button onclick="signInAndLoadDashboard()" id="loadDashboardBtn" disabled>Load Championship Dashboard</button>
      </div>
    </div>
    
    <table id="playerTable">
      <thead>
        <tr>
          <th>Player</th>
          <th>Stacks</th>
          <th>Total Paid</th>
          <th>Status</th>
          <th>Actions</th>
        </tr>
      </thead>
      <tbody id="playerTableBody"></tbody>
    </table>
    
    <div id="prizeResults"></div>
    <div class="charts-section" id="chartsSection"></div>
  </div>
  
  <div class="timer-panel">
    <div class="timer-header">ROUND TIMER</div>
    <div id="roundInfo" class="round-info"></div>
    <div id="timeRemaining" class="time-remaining">20:00</div>
    
    <div class="timer-controls">
      <button id="timerStartBtn" onclick="startTimer()">START</button>
      <button id="timerPauseBtn" onclick="pauseTimer()" disabled>PAUSE</button>
      <button id="timerResetBtn" onclick="resetTimer()">RESET</button>
      <button id="timerSkipBtn" onclick="skipRound()">SKIP ROUND</button>
    </div>
    
    <div id="breakNotice" class="break-notice">
      <strong>BREAK TIME!</strong><br>30 minutes - Add-ons available
    </div>
    
    <div id="finalStage" class="final-stage">
      <strong>FINAL STAGE</strong><br>No more re-buys or add-ons
    </div>
    
    <div class="prize-info">
      <div><strong>Current Prize Pool: ¬£<span id="currentPrizePool">0</span></strong></div>
      <div>1st Place: ¬£<span id="firstPrize">0</span></div>
      <div>2nd Place: ¬£<span id="secondPrize">0</span></div>
    </div>
    
    <audio id="roundAlarm" preload="auto">
      <source src="alarm.mp3" type="audio/mpeg">
      <source src="alarm.mp3" type="audio/mp3">
    </audio>
  </div>

  <script>
    // Debug logging
    console.log('Script starting...');

    // MISSING DECLARATION - ADD THIS:
    let players = [];

    // Configuration - REPLACE WITH YOUR ACTUAL VALUES
    const CLIENT_ID = '341648594146-a9httcsv8e29vr4ehcup08qlpaak5u8a.apps.googleusercontent.com';
    const SPREADSHEET_ID = '1fZWOlbf95Xqg4AnsEm9ga8x1ENrZ_K_0EEF3sEZGz2Y';
    const SCOPES = 'https://www.googleapis.com/auth/spreadsheets';

    // Tournament structure
    const rounds = [
      { name: "Test Round", sb: 0, bb: 0, duration: 5, isTest: true },
      { name: "Round 1", sb: 5, bb: 10, duration: 20 },
      { name: "Round 2", sb: 10, bb: 20, duration: 20 },
      { name: "Round 3", sb: 20, bb: 40, duration: 20 },
      { name: "Round 4", sb: 40, bb: 80, duration: 20 },
      { name: "Break + Add-On", sb: 0, bb: 0, duration: 30, isBreak: true },
      { name: "Round 5", sb: 50, bb: 100, duration: 20 },
      { name: "Round 6", sb: 100, bb: 200, duration: 20 },
      { name: "Round 7", sb: 200, bb: 400, duration: 20 },
      { name: "Round 8", sb: 400, bb: 800, duration: 20 },
      { name: "Round 9", sb: 1000, bb: 2000, duration: 20 }
    ];

    console.log('Rounds defined:', rounds);

    // Pre-populated player list - add your regular players here
    const regularPlayers = [
      'Andre', 'Craig', 'Dale', 'Declan', 'Elton', 'Graham', 'Jacques', 'James', 'Lachy', 'Luciano', 'Malzo', 'Matt', 'Nick', 'Rafa', 'Rhys', 'Roberto'
    ].sort();

    let customPlayers = []; // For new players added during session
    let currentRound = 0;
    let timer = null;
    let timeLeft = 0;
    let tournamentStarted = false;
    let tournamentEnded = false;
    let isBreak = false;
    let isFinalStage = false;
    let timerRunning = false;
    let googleApiReady = false;
    let actionHistory = []; // For undo functionality

    console.log('Global state initialized');

    // ADD THE MISSING FUNCTION:
    function populatePlayerDropdown() {
      const playerSelect = document.getElementById('playerSelect');
      if (!playerSelect) {
        console.error('Player select element not found');
        return;
      }
      
      // Clear existing options except the first one
      playerSelect.innerHTML = '<option value="">Select a player...</option>';
      
      // Add regular players
      regularPlayers.forEach(playerName => {
        const option = document.createElement('option');
        option.value = playerName;
        option.textContent = playerName;
        playerSelect.appendChild(option);
      });
      
      // Add any custom players that were added this session
      customPlayers.forEach(playerName => {
        const option = document.createElement('option');
        option.value = playerName;
        option.textContent = `${playerName} (new)`;
        playerSelect.appendChild(option);
      });
      
      console.log('Player dropdown populated with', regularPlayers.length + customPlayers.length, 'players');
    }

    // Undo functionality
    function recordAction(action, data) {
      actionHistory.push({
        type: action,
        data: data,
        timestamp: Date.now()
      });
      // Keep only last 10 actions
      if (actionHistory.length > 10) {
        actionHistory.shift();
      }
      updateUndoButton();
    }

    function undoLastAction() {
      if (actionHistory.length === 0) {
        showMessage('Nothing to undo', true);
        return;
      }

      const lastAction = actionHistory.pop();
      
      switch (lastAction.type) {
        case 'eliminate':
          const eliminatedPlayer = players.find(p => p.name === lastAction.data.name);
          if (eliminatedPlayer) {
            eliminatedPlayer.eliminated = false;
            eliminatedPlayer.eliminatedBy = undefined; // Clear elimination data
            eliminatedPlayer.eliminationTime = lastAction.data.previousEliminationTime;
            
            // Re-enable timer controls if they were disabled due to winner state
            if (tournamentStarted && !tournamentEnded) {
              document.getElementById('timerStartBtn').disabled = false;
              document.getElementById('timerPauseBtn').disabled = !timerRunning;
              document.getElementById('timerSkipBtn').disabled = false;
            }
            
            showMessage(`Undid elimination of ${lastAction.data.name}`);
          }
          break;
          
        case 'rebuy':
          const rebuyPlayer = players.find(p => p.name === lastAction.data.name);
          if (rebuyPlayer) {
            rebuyPlayer.eliminated = true;
            rebuyPlayer.stacks = lastAction.data.previousStacks;
            rebuyPlayer.totalPaid = lastAction.data.previousPaid;
            showMessage(`Undid rebuy for ${lastAction.data.name}`);
          }
          break;
          
        case 'addon':
          const addonPlayer = players.find(p => p.name === lastAction.data.name);
          if (addonPlayer) {
            addonPlayer.stacks = lastAction.data.previousStacks;
            addonPlayer.totalPaid = lastAction.data.previousPaid;
            addonPlayer.hasAddon = lastAction.data.previousHasAddon || false;
            showMessage(`Undid add-on for ${lastAction.data.name}`);
          }
          break;
      }
      
      updatePlayerTable();
      updateUndoButton();
    }

    function updateUndoButton() {
      const undoBtn = document.getElementById('undoBtn');
      if (undoBtn) {
        undoBtn.disabled = actionHistory.length === 0;
        if (actionHistory.length > 0) {
          const lastAction = actionHistory[actionHistory.length - 1];
          undoBtn.textContent = `Undo ${lastAction.type}`;
        } else {
          undoBtn.textContent = 'Undo';
        }
      }
    }
    // Make functions globally accessible
    window.addPlayer = addPlayer;
    window.removePlayer = removePlayer;
    window.startTournament = startTournament;
    window.endTournament = endTournament;
    window.clearPlayers = clearPlayers;
    window.eliminatePlayer = eliminatePlayer;
    window.rebuyPlayer = rebuyPlayer;
    window.addonPlayer = addonPlayer;
    window.startTimer = startTimer;
    window.pauseTimer = pauseTimer;
    window.resetTimer = resetTimer;
    window.skipRound = skipRound;
    window.signInAndExport = signInAndExport;
    window.signInAndLoadDashboard = signInAndLoadDashboard;
    window.undoLastAction = undoLastAction;

    console.log('Functions attached to window object');

    // Utility functions
    function formatTime(seconds) {
      const m = Math.floor(seconds / 60);
      const s = seconds % 60;
      return `${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')}`;
    }

    function showMessage(message, isError = false) {
      const statusEl = document.getElementById('statusMessage');
      const errorEl = document.getElementById('errorMessage');
      
      // Reset both messages first
      statusEl.classList.remove('show');
      errorEl.classList.remove('show');
      
      setTimeout(() => {
        if (isError) {
          errorEl.textContent = message;
          errorEl.classList.add('show');
        } else {
          statusEl.textContent = message;
          statusEl.classList.add('show');
        }
        
        // Auto-hide after 5 seconds
        setTimeout(() => {
          statusEl.classList.remove('show');
          errorEl.classList.remove('show');
        }, 5000);
      }, 10);
    }

    function playAlarm() {
      console.log('Playing alarm...');
      
      // Primary method: Play your alarm.mp3 file
      const audio = document.getElementById('roundAlarm');
      if (audio) {
        // Reset audio to beginning
        audio.currentTime = 0;
        
        const playPromise = audio.play();
        
        if (playPromise !== undefined) {
          playPromise.then(() => {
            console.log('alarm.mp3 played successfully');
          }).catch(error => {
            console.log('alarm.mp3 playback failed:', error.message);
            console.log('Trying fallback audio methods...');
            playFallbackAlarm();
          });
        } else {
          console.log('Audio play() returned undefined, trying fallback...');
          playFallbackAlarm();
        }
      } else {
        console.log('Audio element not found, trying fallback...');
        playFallbackAlarm();
      }
      
      // Always show visual indicators regardless of audio success
      showVisualAlarm();
    }

    function playFallbackAlarm() {
      // Web Audio API beep as backup
      try {
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        
        // Create 3 beeps
        for (let i = 0; i < 3; i++) {
          setTimeout(() => {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.frequency.value = 800;
            oscillator.type = 'square';
            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.5);
          }, i * 600);
        }
        
        console.log('Fallback Web Audio beeps created');
      } catch (e) {
        console.log('Fallback Web Audio failed:', e.message);
      }
    }

    function showVisualAlarm() {
      // Visual alarm (timer flashing)
      const timerDisplay = document.getElementById('timeRemaining');
      let flashCount = 0;
      const flashInterval = setInterval(() => {
        timerDisplay.style.background = flashCount % 2 === 0 ? '#f44336' : '#ffd54f';
        timerDisplay.style.color = flashCount % 2 === 0 ? '#fff' : '#e65100';
        flashCount++;
        
        if (flashCount >= 6) {
          clearInterval(flashInterval);
          timerDisplay.style.background = '#ffd54f';
          timerDisplay.style.color = '#e65100';
        }
      }, 300);
      
      // Vibration on mobile
      if (navigator.vibrate) {
        navigator.vibrate([200, 100, 200, 100, 200]);
        console.log('Vibration triggered');
      }
      
      // Browser notification
      if (Notification.permission === 'granted') {
        new Notification('Poker Tournament', {
          body: 'Round finished! Time to advance.',
          icon: 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDAiIGhlaWdodD0iNDAiIHZpZXdCb3g9IjAgMCA0MCA0MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjQwIiBoZWlnaHQ9IjQwIiByeD0iMjAiIGZpbGw9IiNmZjk4MDAiLz4KPHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZD0iTTEyIDJMMTMuMDkgOC4yNkwyMCA5TDEzLjA5IDE1Ljc0TDEyIDIyTDEwLjkxIDE1Ljc0TDQgOUwxMC45MSA4LjI2TDEyIDJaIiBmaWxsPSJ3aGl0ZSIvPgo8L3N2Zz4KPC9zdmc+'
        });
      }
    }

    // Request notification permission on app load
    function requestNotificationPermission() {
      if ('Notification' in window && Notification.permission === 'default') {
        Notification.requestPermission().then(permission => {
          console.log('Notification permission:', permission);
        });
      }
    }

    // Google Sheets Integration
    function handleClientLoad() {
      console.log('Loading Google API client...');
      
      // Try the newer Google Identity Services approach first
      if (window.google && window.google.accounts) {
        console.log('Using Google Identity Services (new approach)');
        initWithGIS();
      } else {
        console.log('Falling back to legacy Google API');
        gapi.load('client:auth2', {
          callback: initClient,
          onerror: function() {
            console.error('Failed to load Google API client');
            enableFallbackMode();
          }
        });
      }
    }

    function initWithGIS() {
      try {
        // Initialize the Google Identity Services
        google.accounts.id.initialize({
          client_id: CLIENT_ID,
          callback: handleCredentialResponse
        });

        // Load the Google API client for Sheets
        gapi.load('client', () => {
          gapi.client.init({
            discoveryDocs: ['https://sheets.googleapis.com/$discovery/rest?version=v4']
          }).then(() => {
            console.log('Google Identity Services initialized successfully');
            googleApiReady = true;
            
            // Set up token client for authorization
            window.tokenClient = google.accounts.oauth2.initTokenClient({
              client_id: CLIENT_ID,
              scope: SCOPES,
              callback: (response) => {
                if (response.access_token) {
                  gapi.client.setToken(response);
                  updateSigninStatus(true);
                }
              }
            });
            
            updateSigninStatus(false); // Initially not signed in
          }).catch(error => {
            console.error('GIS client init failed:', error);
            enableFallbackMode();
          });
        });
      } catch (error) {
        console.error('GIS initialization failed:', error);
        enableFallbackMode();
      }
    }

    function handleCredentialResponse(response) {
      console.log('Credential response received');
    }

    function enableFallbackMode() {
      console.log('Enabling fallback mode - Google Sheets disabled');
      showMessage('Google Sheets integration unavailable - tournament results will be shown locally only', true);
      
      setTimeout(() => {
        const exportBtn = document.getElementById('exportBtn');
        const dashboardBtn = document.getElementById('loadDashboardBtn');
        
        if (tournamentEnded) {
          exportBtn.disabled = false;
          dashboardBtn.disabled = true;
          exportBtn.textContent = 'Show Local Results';
          dashboardBtn.textContent = 'Google API Failed';
          exportBtn.onclick = showTournamentSummary;
        }
      }, 1000);
    }

    function initClient() {
      console.log('Attempting to initialize Google API with CLIENT_ID:', CLIENT_ID);
      
      if (CLIENT_ID === 'YOUR_CLIENT_ID.apps.googleusercontent.com') {
        console.error('CLIENT_ID still has placeholder value!');
        showMessage('Google credentials not configured', true);
        return Promise.reject('Invalid CLIENT_ID');
      }
      
      // Try the legacy approach first, then fall back to newer method
      return gapi.client.init({
        apiKey: '', // We don't need API key for OAuth-only requests
        clientId: CLIENT_ID,
        discoveryDocs: ['https://sheets.googleapis.com/$discovery/rest?version=v4'],
        scope: SCOPES
      }).then(() => {
        console.log('Google API initialized successfully');
        googleApiReady = true;
        const authInstance = gapi.auth2.getAuthInstance();
        updateSigninStatus(authInstance.isSignedIn.get());
        authInstance.isSignedIn.listen(updateSigninStatus);
      }).catch(error => {
        console.error('Standard init failed, trying alternative approach:', error);
        
        // Alternative initialization approach
        return gapi.auth2.init({
          client_id: CLIENT_ID,
          scope: SCOPES
        }).then(() => {
          return gapi.client.load('sheets', 'v4');
        }).then(() => {
          console.log('Alternative Google API initialization successful');
          googleApiReady = true;
          const authInstance = gapi.auth2.getAuthInstance();
          updateSigninStatus(authInstance.isSignedIn.get());
          authInstance.isSignedIn.listen(updateSigninStatus);
        }).catch(altError => {
          console.error('Alternative init also failed:', altError);
          showMessage('Google Sheets integration unavailable - OAuth configuration issue', true);
          
          // Enable buttons anyway for testing, but show different text
          setTimeout(() => {
            const exportBtn = document.getElementById('exportBtn');
            const dashboardBtn = document.getElementById('loadDashboardBtn');
            
            if (tournamentEnded) {
              exportBtn.disabled = false;
              dashboardBtn.disabled = true;
              exportBtn.textContent = 'Show Results (Google API Failed)';
              dashboardBtn.textContent = 'Google API Failed';
            }
          }, 1000);
        });
      });
    }

    function updateSigninStatus(isSignedIn) {
      const exportBtn = document.getElementById('exportBtn');
      const dashboardBtn = document.getElementById('loadDashboardBtn');
      
      console.log('updateSigninStatus called:', { isSignedIn, tournamentEnded, googleApiReady });
      
      if (tournamentEnded && googleApiReady) {
        // Always enable buttons when tournament is ended and API is ready
        exportBtn.disabled = false;
        dashboardBtn.disabled = false;
        
        if (isSignedIn) {
          exportBtn.textContent = 'Save Tournament Data';
          dashboardBtn.textContent = 'Load Championship Dashboard';
          exportBtn.onclick = () => exportTournamentData();
          dashboardBtn.onclick = () => loadDashboard();
        } else {
          exportBtn.textContent = 'Sign in to Save';
          dashboardBtn.textContent = 'Sign in to Load Dashboard';
          
          // Make sure the buttons can trigger sign-in
          exportBtn.onclick = () => {
            console.log('Sign in to Save button clicked');
            signInAndExport();
          };
          dashboardBtn.onclick = () => {
            console.log('Sign in to Load Dashboard button clicked');
            signInAndLoadDashboard();
          };
        }
      } else {
        exportBtn.disabled = true;
        dashboardBtn.disabled = true;
        
        if (!tournamentEnded) {
          exportBtn.textContent = 'End Tournament First';
          dashboardBtn.textContent = 'End Tournament First';
        } else if (!googleApiReady) {
          exportBtn.textContent = 'Google API Loading...';
          dashboardBtn.textContent = 'Google API Loading...';
        }
      }
    }

    function signInAndExport() {
      console.log('signInAndExport called, googleApiReady:', googleApiReady);
      
      if (!googleApiReady) {
        // Fallback: show results without saving to Google Sheets
        showTournamentSummary();
        return;
      }
      
      // For Google Identity Services approach
      if (window.tokenClient) {
        console.log('Requesting access token via GIS...');
        // Set up the callback for this specific request
        window.tokenClient.callback = (response) => {
          console.log('Token response received:', response);
          if (response.access_token) {
            console.log('Access token received, setting up API client...');
            gapi.client.setToken(response);
            updateSigninStatus(true);
            exportTournamentData();
          } else {
            console.error('No access token in response');
            showMessage('Authentication failed', true);
          }
        };
        
        try {
          window.tokenClient.requestAccessToken({ prompt: '' });
        } catch (error) {
          console.error('Error requesting access token:', error);
          showMessage('Sign-in failed', true);
        }
        return;
      }
      
      // For legacy approach fallback
      const authInstance = gapi.auth2.getAuthInstance();
      if (authInstance && authInstance.isSignedIn.get()) {
        exportTournamentData();
      } else if (authInstance) {
        authInstance.signIn().then(() => {
          exportTournamentData();
        }).catch(error => {
          showMessage('Sign-in failed', true);
          console.error('Sign-in error:', error);
        });
      } else {
        console.log('No auth available, showing local summary');
        showTournamentSummary();
      }
    }

    function showTournamentSummary() {
      const data = collectCurrentTournamentData();
      const summary = `
Tournament Results Summary:
Date: ${data.date}
Winner: ${data.first}
2nd Place: ${data.second}
All Players: ${data.results.join(', ')}

Note: Google Sheets integration not available - results not saved automatically.
      `;
      
      alert(summary);
      console.log('Tournament Data:', data);
      showMessage('Tournament results displayed (Google Sheets not available)');
    }

    function signInAndLoadDashboard() {
      if (!googleApiReady) {
        showMessage('Google API not ready', true);
        return;
      }
      
      const authInstance = gapi.auth2.getAuthInstance();
      if (authInstance.isSignedIn.get()) {
        loadDashboard();
      } else {
        authInstance.signIn().then(() => {
          loadDashboard();
        }).catch(error => {
          showMessage('Sign-in failed', true);
          console.error('Sign-in error:', error);
        });
      }
    }

    function collectCurrentTournamentData() {
      const now = new Date();
      const date = now.toISOString().split('T')[0];
      const timestamp = now.toLocaleTimeString();
      const tournamentId = `${date}_${timestamp.replace(/:/g, '-')}`;
      
      console.log('=== TOURNAMENT DATA COLLECTION START ===');
      console.log('Tournament ID:', tournamentId);
      console.log('Raw players data:', players.map(p => ({
        name: p.name, 
        eliminated: p.eliminated, 
        eliminationTime: p.eliminationTime,
        stacks: p.stacks,
        totalPaid: p.totalPaid
      })));
      
      // Sort players by elimination time (most recent elimination = highest finish)
      const allPlayersSorted = [...players].sort((a, b) => {
        if (!a.eliminated && !b.eliminated) return 0;
        if (!a.eliminated) return -1; // a is active (winner)
        if (!b.eliminated) return 1; // b is active (winner)
        
        // Both eliminated - most recent elimination time = better finish
        return (b.eliminationTime || 0) - (a.eliminationTime || 0);
      });
      
      console.log('All players sorted by finish:', allPlayersSorted.map(p => `${p.name}: ${p.eliminated ? 'eliminated at ' + new Date(p.eliminationTime).toLocaleTimeString() : 'WINNER'}`));
      
      // Calculate prize pool with ¬£5 rounding for easier cash handling
      const totalPaid = players.reduce((sum, p) => sum + p.totalPaid, 0);
      const houseFee = totalPaid > 100 ? 10 : 5;
      const prizePool = totalPaid - houseFee;
      
      const rawFirstPrize = prizePool * 0.8;
      const rawSecondPrize = prizePool * 0.2;
      const firstPrize = Math.round(rawFirstPrize / 5) * 5;
      const secondPrize = Math.round(rawSecondPrize / 5) * 5;
      
      console.log('Prize calculations:', { totalPaid, houseFee, prizePool, firstPrize, secondPrize });
      
      // Create individual player records
      const playerRecords = [];
      
      allPlayersSorted.forEach((player, index) => {
        const finishPosition = player.eliminated ? (allPlayersSorted.filter(p => !p.eliminated).length + index) : 1;
        let earnings = 0;
        
        // Award prize money
        if (finishPosition === 1) earnings = firstPrize;
        else if (finishPosition === 2) earnings = secondPrize;
        
        // Calculate rebuys and addons from total paid
        const baseStacks = 1;
        const additionalStacks = player.stacks - baseStacks;
        const baseCost = 5;
        const additionalCost = player.totalPaid - baseCost;
        const rebuys = player.eliminated ? Math.max(0, additionalStacks - (player.hasAddon ? 1 : 0)) : additionalStacks - (player.hasAddon ? 1 : 0);
        const addons = player.hasAddon ? 1 : 0;
        
        const playerRecord = {
          date,
          timestamp,
          tournamentId,
          playerName: player.name,
          finishPosition,
          fieldSize: players.length,
          amountPaid: player.totalPaid,
          earnings,
          rebuys: Math.max(0, rebuys),
          addons,
          roi: player.totalPaid > 0 ? ((earnings - player.totalPaid) / player.totalPaid * 100).toFixed(1) : 0,
          eliminatedBy: player.eliminated ? (player.eliminatedBy || 'N/A') : '' // Only set for eliminated players
        };
        
        playerRecords.push(playerRecord);
        console.log(`Player record: ${player.name} - Position: ${finishPosition}, Paid: ¬£${player.totalPaid}, Earned: ¬£${earnings}, ROI: ${playerRecord.roi}%`);
      });
      
      console.log('=== FINAL TOURNAMENT DATA ===');
      console.log('Total player records:', playerRecords.length);
      console.log('Tournament ID:', tournamentId);
      console.log('=== END COLLECTION ===');
      
      return {
        tournamentId,
        playerRecords,
        summary: {
          date,
          timestamp,
          fieldSize: players.length,
          prizePool,
          winner: allPlayersSorted[0]?.name || '',
          second: allPlayersSorted.find(p => p.eliminated)?.name || ''
        }
      };
    }

    function exportTournamentData() {
      if (!tournamentEnded) {
        showMessage('Tournament must be ended first', true);
        return;
      }

      const data = collectCurrentTournamentData();
      console.log('About to export tournament data:', data);
      
      // Prepare rows for Google Sheets - each player gets their own row
      const rows = data.playerRecords.map(record => [
        record.date,
        record.timestamp,
        record.tournamentId,
        record.playerName,
        record.finishPosition,
        record.fieldSize,
        record.amountPaid,
        record.earnings,
        record.rebuys,
        record.addons,
        record.roi,
        record.eliminatedBy
      ]);
      
      console.log('Rows to export:', rows);
      
      gapi.client.sheets.spreadsheets.values.append({
        spreadsheetId: SPREADSHEET_ID,
        range: 'PlayerResults!A:L', // Updated to include new EliminatedBy column
        valueInputOption: 'USER_ENTERED',
        resource: {
          values: rows
        }
      }).then(response => {
        showMessage(`Tournament data saved successfully! ${rows.length} player records exported.`);
        console.log('Export successful:', response);
      }).catch(error => {
        showMessage('Failed to save tournament data', true);
        console.error('Export error:', error);
      });
    }

    function loadDashboard() {
      gapi.client.sheets.spreadsheets.values.get({
        spreadsheetId: SPREADSHEET_ID,
        range: 'PlayerResults!A:L'  // Updated to include EliminatedBy column
      }).then(response => {
        const rows = response.result.values || [];
        buildDashboardWithTabs(rows);
        showMessage('Championship dashboard loaded!');
      }).catch(error => {
        showMessage('Failed to load dashboard data', true);
        console.error('Dashboard load error:', error);
      });
    }

    function buildDashboardWithTabs(rows) {
      const section = document.getElementById('chartsSection');
      
      if (!rows || rows.length <= 1) {
        section.innerHTML = '<h3>Championship Dashboard</h3><p>No tournament data found to display.</p>';
        return;
      }
      
      // Calculate player stats (reuse existing logic)
      const stats = calculatePlayerStats(rows);
      
      section.innerHTML = `
        <h3>Championship Dashboard</h3>
        <div class="dashboard-tabs">
          <button class="dashboard-tab active" onclick="switchDashboardTab('overview')">üìä Overview</button>
          <button class="dashboard-tab" onclick="switchDashboardTab('titles')">üèÜ Titles</button>
          <button class="dashboard-tab" onclick="switchDashboardTab('stats')">üìà Detailed Stats</button>
        </div>
        <div class="dashboard-tab-content">
          <div id="overview-panel" class="dashboard-tab-panel active">
            ${buildOverviewPanel(stats)}
          </div>
          <div id="titles-panel" class="dashboard-tab-panel">
            ${buildTitlesPanel(stats)}
          </div>
          <div id="stats-panel" class="dashboard-tab-panel">
            ${buildStatsPanel(stats)}
          </div>
        </div>
      `;
    }

    // Add tab switching function to global scope
    window.switchDashboardTab = function(tabName) {
      // Remove active class from all tabs and panels
      document.querySelectorAll('.dashboard-tab').forEach(tab => tab.classList.remove('active'));
      document.querySelectorAll('.dashboard-tab-panel').forEach(panel => panel.classList.remove('active'));
      
      // Add active class to selected tab and panel
      event.target.classList.add('active');
      document.getElementById(tabName + '-panel').classList.add('active');
    };

    function calculatePlayerStats(rows) {
      const stats = {};
      
      // Skip header row if it exists
      const dataRows = rows.length > 0 && rows[0][0] === 'Date' ? rows.slice(1) : rows;
      
      dataRows.forEach((row, index) => {
        if (row.length < 8) return;
        
        const [date, time, tournamentId, playerName, position, fieldSize, amountPaid, earnings, rebuys, addons, roi, eliminatedBy] = row;
        
        if (!playerName) return;
        
        const player = playerName.trim();
        
        // Initialize player stats
        if (!stats[player]) {
          stats[player] = {
            played: 0,
            wins: 0,
            seconds: 0,
            thirds: 0, // Track 3rd places for bubble boy
            totalEarnings: 0,
            totalSpent: 0,
            totalRebuys: 0,
            totalAddons: 0,
            bestFinish: 999,
            eliminations: 0, // Track how many people this player eliminated
            firstOuts: 0, // Track first eliminations
            cashes: 0
          };
        }
        
        const pos = parseInt(position) || 999;
        const paid = parseFloat(amountPaid) || 0;
        const earned = parseFloat(earnings) || 0;
        const rebuyCount = parseInt(rebuys) || 0;
        const addonCount = parseInt(addons) || 0;
        const field = parseInt(fieldSize) || 0; // Changed variable name to avoid conflict
        
        // Update player statistics
        stats[player].played++;
        stats[player].totalSpent += paid;
        stats[player].totalEarnings += earned;
        stats[player].totalRebuys += rebuyCount;
        stats[player].totalAddons += addonCount;
        
        // Track positions
        if (pos === 1) stats[player].wins++;
        if (pos === 2) stats[player].seconds++;
        if (pos === 3) stats[player].thirds++; // Track 3rd place for bubble boy
        if (pos <= 2) stats[player].cashes++;
        if (pos === field) stats[player].firstOuts++; // Last position = first out
        
        if (pos < stats[player].bestFinish) stats[player].bestFinish = pos;
        
        // Track eliminations caused by this player
        if (eliminatedBy && eliminatedBy === player) {
          if (!stats[eliminatedBy]) {
            stats[eliminatedBy] = {
              played: 0, wins: 0, seconds: 0, thirds: 0, totalEarnings: 0, totalSpent: 0,
              totalRebuys: 0, totalAddons: 0, bestFinish: 999, eliminations: 0,
              firstOuts: 0, cashes: 0
            };
          }
          stats[eliminatedBy].eliminations++;
        }
      });
      
      // Calculate derived stats
      Object.keys(stats).forEach(player => {
        const s = stats[player];
        s.avgROI = s.totalSpent > 0 ? ((s.totalEarnings - s.totalSpent) / s.totalSpent * 100).toFixed(1) : '0.0';
        s.winRate = s.played > 0 ? ((s.wins / s.played) * 100).toFixed(1) : '0.0';
        s.cashRate = s.played > 0 ? ((s.cashes / s.played) * 100).toFixed(1) : '0.0';
        s.phoenixCount = s.totalRebuys + s.totalAddons; // Total second chances
        if (s.bestFinish === 999) s.bestFinish = 'N/A';
      });
      
      return stats;
    }

    function buildOverviewPanel(stats) {
      // Olympic-style sorting for leaderboard
      const sortedStats = Object.entries(stats)
        .sort((a, b) => {
          if (b[1].wins !== a[1].wins) return b[1].wins - a[1].wins;
          if (b[1].seconds !== a[1].seconds) return b[1].seconds - a[1].seconds;
          return b[1].played - a[1].played;
        });
      
      let html = '<h4>Championship Leaderboard</h4>';
      html += `
        <table>
          <thead>
            <tr>
              <th>Rank</th>
              <th>Player</th>
              <th>ü•á Wins</th>
              <th>ü•à 2nd</th>
              <th>Tournaments</th>
            </tr>
          </thead>
          <tbody>
      `;
      
      if (sortedStats.length === 0) {
        html += '<tr><td colspan="5">No tournament data available</td></tr>';
      } else {
        sortedStats.forEach(([name, s], index) => {
          html += `
            <tr>
              <td><strong>${index + 1}</strong></td>
              <td><strong>${name}</strong></td>
              <td style="text-align: center; font-size: 1.2em;">${s.wins}</td>
              <td style="text-align: center; font-size: 1.2em;">${s.seconds}</td>
              <td style="text-align: center;">${s.played}</td>
            </tr>
          `;
        });
      }
      
      html += '</tbody></table>';
      return html;
    }

    function buildTitlesPanel(stats) {
      const titles = calculateTitles(stats);
      
      let html = '<h4>Championship Title Holders</h4>';
      html += '<div class="titles-grid">';
      
      titles.forEach(title => {
        html += `
          <div class="title-card">
            <span class="title-card-emoji">${title.emoji}</span>
            <div class="title-card-name">${title.name}</div>
            <div class="title-card-holder">${title.holder}</div>
            <div class="title-card-stat">${title.stat}</div>
          </div>
        `;
      });
      
      html += '</div>';
      return html;
    }

    function buildStatsPanel(stats) {
      const sortedStats = Object.entries(stats)
        .sort((a, b) => {
          if (b[1].wins !== a[1].wins) return b[1].wins - a[1].wins;
          if (b[1].seconds !== a[1].seconds) return b[1].seconds - a[1].seconds;
          return b[1].played - a[1].played;
        });
      
      let html = '<h4>Detailed Player Statistics</h4>';
      html += `
        <table>
          <thead>
            <tr>
              <th>Rank</th>
              <th>Player</th>
              <th>ü•á Wins</th>
              <th>ü•à 2nd</th>
              <th>Tournaments</th>
              <th>Cash Rate</th>
              <th>Win Rate</th>
              <th>Rebuys</th>
              <th>Add-ons</th>
            </tr>
          </thead>
          <tbody>
      `;
      
      if (sortedStats.length === 0) {
        html += '<tr><td colspan="9">No tournament data available</td></tr>';
      } else {
        sortedStats.forEach(([name, s], index) => {
          html += `
            <tr>
              <td><strong>${index + 1}</strong></td>
              <td><strong>${name}</strong></td>
              <td style="text-align: center;">${s.wins}</td>
              <td style="text-align: center;">${s.seconds}</td>
              <td style="text-align: center;">${s.played}</td>
              <td style="text-align: center;">${s.cashRate}%</td>
              <td style="text-align: center;">${s.winRate}%</td>
              <td style="text-align: center;">${s.totalRebuys}</td>
              <td style="text-align: center;">${s.totalAddons}</td>
            </tr>
          `;
        });
      }
      
      html += '</tbody></table>';
      return html;
    }

    function calculateTitles(stats) {
      const sortedByWins = Object.entries(stats).sort((a, b) => b[1].wins - a[1].wins);
      const sortedBySeconds = Object.entries(stats).sort((a, b) => b[1].seconds - a[1].seconds);
      const sortedByEarnings = Object.entries(stats).sort((a, b) => (b[1].totalEarnings - b[1].totalSpent) - (a[1].totalEarnings - a[1].totalSpent));
      const sortedByAttendance = Object.entries(stats).filter(([name]) => name !== 'Rafa').sort((a, b) => b[1].played - a[1].played);
      const sortedByEliminations = Object.entries(stats).sort((a, b) => b[1].eliminations - a[1].eliminations);
      const sortedByFirstOuts = Object.entries(stats).sort((a, b) => b[1].firstOuts - a[1].firstOuts);
      const sortedByPhoenix = Object.entries(stats).sort((a, b) => b[1].phoenixCount - a[1].phoenixCount);
      const sortedByBubbles = Object.entries(stats).sort((a, b) => b[1].thirds - a[1].thirds);
      
      const titles = [];
      
      if (sortedByWins.length > 0 && sortedByWins[0][1].wins > 0) {
        titles.push({
          emoji: 'üëë',
          name: 'The Champion',
          holder: sortedByWins[0][0],
          stat: `${sortedByWins[0][1].wins} tournament wins`
        });
      }
      
      if (sortedBySeconds.length > 0 && sortedBySeconds[0][1].seconds > 0) {
        titles.push({
          emoji: 'ü•à',
          name: 'The Runner-up',
          holder: sortedBySeconds[0][0],
          stat: `${sortedBySeconds[0][1].seconds} second places`
        });
      }
      
      if (sortedByEarnings.length > 0) {
        const profit = sortedByEarnings[0][1].totalEarnings - sortedByEarnings[0][1].totalSpent;
        if (profit > 0) {
          titles.push({
            emoji: 'üí∞',
            name: 'Elon Musk',
            holder: sortedByEarnings[0][0],
            stat: `¬£${profit.toFixed(2)} profit`
          });
        }
      }
      
      if (sortedByAttendance.length > 0) {
        titles.push({
          emoji: 'üè†',
          name: 'The Permanent Fixture',
          holder: sortedByAttendance[0][0],
          stat: `${sortedByAttendance[0][1].played} tournaments`
        });
      }
      
      if (sortedByEliminations.length > 0 && sortedByEliminations[0][1].eliminations > 0) {
        titles.push({
          emoji: 'üíÄ',
          name: 'The Killer',
          holder: sortedByEliminations[0][0],
          stat: `${sortedByEliminations[0][1].eliminations} eliminations`
        });
      }
      
      if (sortedByFirstOuts.length > 0 && sortedByFirstOuts[0][1].firstOuts > 0) {
        titles.push({
          emoji: 'üê¶',
          name: 'The Early Bird',
          holder: sortedByFirstOuts[0][0],
          stat: `${sortedByFirstOuts[0][1].firstOuts} first eliminations`
        });
      }
      
      if (sortedByPhoenix.length > 0 && sortedByPhoenix[0][1].phoenixCount > 0) {
        titles.push({
          emoji: 'üî•',
          name: 'The Phoenix',
          holder: sortedByPhoenix[0][0],
          stat: `${sortedByPhoenix[0][1].phoenixCount} second chances`
        });
      }
      
      if (sortedByBubbles.length > 0 && sortedByBubbles[0][1].thirds > 0) {
        titles.push({
          emoji: 'ü´ß',
          name: 'Bubble Boy',
          holder: sortedByBubbles[0][0],
          stat: `${sortedByBubbles[0][1].thirds} third place finishes`
        });
      }
      
      return titles;
    }

    // Player management
    function updatePlayerTable() {
      const tbody = document.getElementById('playerTableBody');
      tbody.innerHTML = '';
      
      // Check if we have a winner (only one active player left)
      const activePlayers = players.filter(p => !p.eliminated);
      const hasWinner = tournamentStarted && !tournamentEnded && activePlayers.length === 1;
      
      players.forEach((player, index) => {
        const tr = document.createElement('tr');
        if (player.eliminated) {
          tr.classList.add('eliminated');
        }
        
        let actions = '';
        if (!tournamentStarted && !tournamentEnded) {
          actions = `<button onclick="removePlayer(${index})">Remove</button>`;
        } else if (tournamentStarted && !tournamentEnded) {
          // If this is the winner, show winner banner
          if (hasWinner && !player.eliminated) {
            actions = `<div style="background: linear-gradient(90deg, #ffd700, #ffed4e); 
                              color: #e65100; 
                              padding: 8px 16px; 
                              border-radius: 20px; 
                              font-weight: bold; 
                              text-align: center; 
                              box-shadow: 0 2px 8px rgba(255, 215, 0, 0.4);
                              border: 2px solid #ffc107;">
                        üèÜ WINNER üèÜ
                      </div>`;
          } else {
            // Show eliminate button for active players (including during breaks)
            if (!player.eliminated) {
              actions += `<button onclick="eliminatePlayer(${index})">Eliminate</button>`;
            }
            
            // Re-buy available for eliminated players BEFORE final stage (including during break)
            if (player.eliminated && !isFinalStage) {
              actions += `<button class="rebuy-btn" onclick="rebuyPlayer(${index})">Re-buy ¬£5</button>`;
            }
            
            // Add-on available for ALL players ONLY during breaks (before final stage) and only once per player
            if (isBreak && !isFinalStage && !player.hasAddon) {
              actions += `<button class="addon-btn" onclick="addonPlayer(${index})">Add-on ¬£5</button>`;
            }
          }
        }
        
        tr.innerHTML = `
          <td><strong>${player.name}</strong></td>
          <td>${player.stacks}</td>
          <td>¬£${player.totalPaid}</td>
          <td>${player.eliminated ? 'Eliminated' : (hasWinner && !player.eliminated ? 'WINNER' : 'Active')}</td>
          <td>${actions}</td>
        `;
        tbody.appendChild(tr);
      });
      
      updatePrizeInfo();
      checkForWinner();
    }

    function checkForWinner() {
      if (!tournamentStarted || tournamentEnded) return;
      
      const activePlayers = players.filter(p => !p.eliminated);
      
      if (activePlayers.length === 1) {
        // Stop the timer immediately
        if (timer) {
          clearInterval(timer);
        }
        timerRunning = false;
        
        document.getElementById('timerStartBtn').disabled = true;
        document.getElementById('timerPauseBtn').disabled = true;
        document.getElementById('timerSkipBtn').disabled = true;
        
        showMessage(`üèÜ ${activePlayers[0].name} is the winner! Click "End Tournament" to finish and save results.`);
        
        // Force table update to show winner state
        setTimeout(() => {
          updatePlayerTable();
        }, 100);
      }
    }

    function updatePrizeInfo() {
      const totalPaid = players.reduce((sum, p) => sum + p.totalPaid, 0);
      const houseFee = totalPaid > 100 ? 10 : 5;
      const prizePool = Math.max(0, totalPaid - houseFee);
      
      // Round prizes to nearest ¬£5 for easier cash handling
      const rawFirstPrize = prizePool * 0.8;
      const rawSecondPrize = prizePool * 0.2;
      
      const firstPrize = Math.round(rawFirstPrize / 5) * 5;
      const secondPrize = Math.round(rawSecondPrize / 5) * 5;
      
      document.getElementById('playerCount').textContent = 
        `Players: ${players.length} | Prize Pot: ¬£${prizePool} | House Fee: ¬£${houseFee}`;
      document.getElementById('currentPrizePool').textContent = prizePool;
      document.getElementById('firstPrize').textContent = firstPrize;
      document.getElementById('secondPrize').textContent = secondPrize;
    }

    // FIXED addPlayer function to handle dropdown:
    function addPlayer() {
      const input = document.getElementById('playerNameInput');
      const select = document.getElementById('playerSelect');
      
      // Check if a player was selected from dropdown or typed in input
      const name = (select.value || input.value).trim();
      
      if (!name) {
        showMessage('Please select or enter a player name', true);
        return;
      }
      
      if (players.some(p => p.name.toLowerCase() === name.toLowerCase())) {
        showMessage('Player already exists', true);
        return;
      }
      
      if (tournamentStarted) {
        showMessage('Cannot add players after tournament has started', true);
        return;
      }
      
      // If the name was typed (not in regularPlayers), add to customPlayers
      if (!regularPlayers.includes(name)) {
        if (!customPlayers.includes(name)) {
          customPlayers.push(name);
          customPlayers.sort(); // Keep sorted
          populatePlayerDropdown(); // Update dropdown with new custom player
        }
      }
      
      players.push({
        name: name,
        stacks: 1,
        totalPaid: 5,
        eliminated: false,
        hasAddon: false, // Track if player has used their one add-on
        eliminationTime: null // Track when they were eliminated
      });
      
      // Clear both input and select
      input.value = '';
      select.value = '';
      input.focus();
      updatePlayerTable();
      showMessage(`${name} added to tournament`);
    }

    function removePlayer(index) {
      if (tournamentStarted) {
        showMessage('Cannot remove players after tournament has started', true);
        return;
      }
      
      const playerName = players[index].name;
      players.splice(index, 1);
      updatePlayerTable();
      showMessage(`${playerName} removed from tournament`);
    }

    function eliminatePlayer(index) {
      if (!tournamentStarted || tournamentEnded) return;
      
      const player = players[index];
      
      // Get list of all players (including eliminated ones) for the elimination dropdown
      const availablePlayers = players.map(p => p.name);
      
      // Create dropdown for who eliminated this player
      const eliminatorOptions = availablePlayers
        .filter(name => name !== player.name) // Can't eliminate yourself
        .map(name => `<option value="${name}">${name}</option>`)
        .join('');
      
      const eliminatorHtml = `
        <div style="margin: 10px 0;">
          <label for="eliminatorSelect">Who eliminated ${player.name}?</label><br>
          <select id="eliminatorSelect" style="padding: 5px; margin: 5px 0; width: 200px;">
            <option value="N/A">N/A (Self-elimination/Split pot)</option>
            ${eliminatorOptions}
          </select>
        </div>
      `;
      
      // Show a custom dialog for elimination
      const eliminationDialog = document.createElement('div');
      eliminationDialog.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: white;
        border: 3px solid #ffa726;
        border-radius: 10px;
        padding: 20px;
        box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        z-index: 1000;
        text-align: center;
      `;
      
      eliminationDialog.innerHTML = `
        <h3 style="color: #e65100; margin-top: 0;">Eliminate ${player.name}</h3>
        ${eliminatorHtml}
        <div style="margin-top: 15px;">
          <button onclick="confirmElimination(${index})" style="margin: 5px; background: #f44336; color: white;">Confirm Elimination</button>
          <button onclick="cancelElimination()" style="margin: 5px;">Cancel</button>
        </div>
      `;
      
      // Add backdrop
      const backdrop = document.createElement('div');
      backdrop.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0,0,0,0.5);
        z-index: 999;
      `;
      backdrop.onclick = () => cancelElimination();
      
      document.body.appendChild(backdrop);
      document.body.appendChild(eliminationDialog);
      
      // Store references for cleanup
      window.currentEliminationDialog = eliminationDialog;
      window.currentEliminationBackdrop = backdrop;
    }

    // Add these new global functions
    window.confirmElimination = function(index) {
      const player = players[index];
      const eliminatorSelect = document.getElementById('eliminatorSelect');
      const eliminatedBy = eliminatorSelect.value;
      
      // Get the current timestamp for elimination order
      player.eliminationTime = Date.now();
      
      recordAction('eliminate', {
        name: player.name,
        previousEliminated: player.eliminated,
        previousEliminationTime: player.eliminationTime,
        eliminatedBy: eliminatedBy
      });
      
      player.eliminated = true;
      player.eliminatedBy = eliminatedBy; // Store who eliminated them
      
      // Calculate current position based on how many are left
      const remainingPlayers = players.filter(p => !p.eliminated).length;
      const position = remainingPlayers + 1; // +1 because this player just got eliminated
      
      // Clean up dialog
      cancelElimination();
      
      // Update table and check for winner
      updatePlayerTable();
      
      const eliminationMsg = eliminatedBy === 'N/A' ? 
        `${player.name} eliminated from tournament (${position}${getSuffix(position)} place)` :
        `${player.name} eliminated by ${eliminatedBy} (${position}${getSuffix(position)} place)`;
      
      showMessage(eliminationMsg);
      
      // Force winner check after a brief delay to ensure table is updated
      setTimeout(() => {
        console.log('Forcing winner check after elimination...');
        checkForWinner();
      }, 200);
    };

    window.cancelElimination = function() {
      if (window.currentEliminationDialog) {
        document.body.removeChild(window.currentEliminationDialog);
        window.currentEliminationDialog = null;
      }
      if (window.currentEliminationBackdrop) {
        document.body.removeChild(window.currentEliminationBackdrop);
        window.currentEliminationBackdrop = null;
      }
    };

    function getSuffix(num) {
      if (num % 10 === 1 && num % 100 !== 11) return 'st';
      if (num % 10 === 2 && num % 100 !== 12) return 'nd';
      if (num % 10 === 3 && num % 100 !== 13) return 'rd';
      return 'th';
    }

    function rebuyPlayer(index) {
      if (tournamentEnded || isFinalStage) {
        showMessage('Re-buys not available in final stage', true);
        return;
      }
      
      const player = players[index];
      if (!player.eliminated) {
        showMessage('Player must be eliminated to re-buy', true);
        return;
      }
      
      recordAction('rebuy', {
        name: player.name,
        previousStacks: player.stacks,
        previousPaid: player.totalPaid
      });
      
      player.eliminated = false;
      player.stacks++;
      player.totalPaid += 5;
      updatePlayerTable();
      showMessage(`${player.name} re-bought for ¬£5`);
    }

    function addonPlayer(index) {
      if (!isBreak || tournamentEnded || isFinalStage) {
        showMessage('Add-ons only available during breaks before final stage', true);
        return;
      }
      
      const player = players[index];
      
      if (player.hasAddon) {
        showMessage('Player has already used their one add-on', true);
        return;
      }
      
      recordAction('addon', {
        name: player.name,
        previousStacks: player.stacks,
        previousPaid: player.totalPaid,
        previousHasAddon: player.hasAddon
      });
      
      player.stacks++;
      player.totalPaid += 5;
      player.hasAddon = true;
      updatePlayerTable();
      showMessage(`${player.name} purchased add-on for ¬£5`);
    }

    function clearPlayers() {
      if (tournamentStarted && !tournamentEnded) {
        if (!confirm('Tournament is in progress. Are you sure you want to clear all players?')) {
          return;
        }
      }
      
      players = [];
      tournamentStarted = false;
      tournamentEnded = false;
      resetTournament();
      updatePlayerTable();
      showMessage('All players cleared');
    }

    // Tournament management
    function startTournament() {
      if (players.length < 2) {
        showMessage('Need at least 2 players to start tournament', true);
        return;
      }
      
      tournamentStarted = true;
      tournamentEnded = false;
      
      document.getElementById('startBtn').disabled = true;
      document.getElementById('endBtn').disabled = false;
      document.getElementById('exportBtn').disabled = true;
      document.getElementById('loadDashboardBtn').disabled = true;
      
      // Start the timer automatically
      currentRound = 0;
      updateRoundDisplay();
      startTimer();
      
      updatePlayerTable();
      showMessage('Tournament started! Timer is running.');
    }

    function endTournament() {
      if (!confirm('Are you sure you want to end the tournament?')) {
        return;
      }
      
      tournamentEnded = true;
      tournamentStarted = false;
      clearInterval(timer);
      timerRunning = false;
      
      document.getElementById('endBtn').disabled = true;
      document.getElementById('timerStartBtn').disabled = true;
      document.getElementById('timerPauseBtn').disabled = true;
      document.getElementById('timerSkipBtn').disabled = true;
      
      const activePlayers = players.filter(p => !p.eliminated);
      
      // Update buttons based on Google API status
      if (googleApiReady) {
        // For Google Identity Services, we don't have a persistent isSignedIn state
        // So we enable the buttons and let the sign-in happen when clicked
        updateSigninStatus(false); // Start as not signed in, will prompt when clicked
      } else {
        const exportBtn = document.getElementById('exportBtn');
        const dashboardBtn = document.getElementById('loadDashboardBtn');
        exportBtn.disabled = true;
        dashboardBtn.disabled = true;
        exportBtn.textContent = 'Google API Not Available';
        dashboardBtn.textContent = 'Google API Not Available';
      }
      
      updatePlayerTable();
      displayFinalResults(activePlayers);
      showMessage('Tournament ended! You can now save the results.');
    }

    function displayFinalResults(finalists) {
      const resultsDiv = document.getElementById('prizeResults');
      if (finalists.length === 0) {
        resultsDiv.innerHTML = '<div class="prize-info"><h3>No finalists!</h3></div>';
        return;
      }
      
      const totalPaid = players.reduce((sum, p) => sum + p.totalPaid, 0);
      const houseFee = totalPaid > 100 ? 10 : 5;
      const prizePool = totalPaid - houseFee;
      
      // Round prizes to nearest ¬£5 for easier cash handling
      const rawFirstPrize = prizePool * 0.8;
      const rawSecondPrize = prizePool * 0.2;
      const firstPrize = Math.round(rawFirstPrize / 5) * 5;
      const secondPrize = Math.round(rawSecondPrize / 5) * 5;
      
      // Sort players by elimination time (most recent elimination = highest finish)
      // Active players (not eliminated) come first
      const allPlayersSorted = [...players].sort((a, b) => {
        if (!a.eliminated && !b.eliminated) return 0; // Both active - doesn't matter
        if (!a.eliminated) return -1; // a is active (winner)
        if (!b.eliminated) return 1; // b is active (winner)
        
        // Both eliminated - most recent elimination time = better finish (2nd place)
        return (b.eliminationTime || 0) - (a.eliminationTime || 0);
      });
      
      console.log('Final ranking:', allPlayersSorted.map(p => `${p.name}: ${p.eliminated ? 'eliminated at ' + new Date(p.eliminationTime).toLocaleTimeString() : 'active'}`));
      
      let resultsHTML = '<div class="prize-info"><h3>Final Results</h3>';
      
      // 1st Place (active player)
      const winner = allPlayersSorted.find(p => !p.eliminated);
      if (winner) {
        resultsHTML += `<div style="font-size: 1.4rem; color: #d84315; margin: 10px 0;">
          ü•á <strong>1st Place: ${winner.name}</strong> - ¬£${firstPrize}
        </div>`;
      }
      
      // 2nd Place (most recently eliminated player)
      const secondPlace = allPlayersSorted.find(p => p.eliminated);
      if (secondPlace) {
        resultsHTML += `<div style="font-size: 1.2rem; color: #d84315; margin: 10px 0;">
          ü•à <strong>2nd Place: ${secondPlace.name}</strong> - ¬£${secondPrize}
        </div>`;
      } else {
        resultsHTML += `<div style="font-size: 1.2rem; color: #666; margin: 10px 0;">
          ü•à <strong>2nd Place:</strong> No qualifying player - ¬£0
        </div>`;
      }
      
      // Other finalists (remaining eliminated players in order)
      const otherFinalists = allPlayersSorted.filter(p => p.eliminated && p !== secondPlace);
      if (otherFinalists.length > 0) {
        resultsHTML += '<div style="margin-top: 15px;"><strong>Other Finalists:</strong><br>';
        otherFinalists.forEach((player, index) => {
          resultsHTML += `${index + 3}. ${player.name}<br>`;
        });
        resultsHTML += '</div>';
      }
      
      resultsHTML += '</div>';
      resultsDiv.innerHTML = resultsHTML;
    }

    function resetTournament() {
      clearInterval(timer);
      timerRunning = false;
      currentRound = 0;
      timeLeft = 0;
      isBreak = false;
      isFinalStage = false;
      
      document.getElementById('startBtn').disabled = false;
      document.getElementById('endBtn').disabled = true;
      document.getElementById('exportBtn').disabled = true;
      document.getElementById('loadDashboardBtn').disabled = true;
      document.getElementById('timerStartBtn').disabled = false;
      document.getElementById('timerPauseBtn').disabled = true;
      document.getElementById('timerSkipBtn').disabled = false;
      
      document.getElementById('prizeResults').innerHTML = '';
      document.getElementById('chartsSection').innerHTML = '';
      
      updateRoundDisplay();
    }

    // Timer management
    function updateRoundDisplay() {
      const round = rounds[currentRound];
      let roundInfoHTML = `<div style="font-size: 1.6rem; margin-bottom: 15px;">${round.name}</div>`;
      
      if (!round.isBreak && !round.isTest) {
        roundInfoHTML += `
          <div class="blind-display">SB: ${round.sb} | BB: ${round.bb}</div>
          <div style="font-size: 1.1rem; margin-top: 10px;">Duration: ${round.duration} minutes</div>
        `;
      } else if (round.isBreak) {
        roundInfoHTML += `
          <div class="blind-display">BREAK TIME</div>
          <div style="font-size: 1.1rem; margin-top: 10px;">Duration: ${round.duration} minutes</div>
        `;
      } else if (round.isTest) {
        roundInfoHTML += `
          <div class="blind-display">TEST ROUND</div>
          <div style="font-size: 1.1rem; margin-top: 10px;">Duration: ${round.duration} seconds</div>
        `;
      }
      
      document.getElementById('roundInfo').innerHTML = roundInfoHTML;
      
      // Set time left - test rounds use seconds, others use minutes
      timeLeft = round.isTest ? round.duration : round.duration * 60;
      document.getElementById('timeRemaining').textContent = formatTime(timeLeft);
      
      // Update break and final stage indicators
      isBreak = !!round.isBreak;
      isFinalStage = currentRound > 5; // Final stage starts AFTER break (Round 6+)
      
      document.getElementById('breakNotice').style.display = isBreak ? 'block' : 'none';
      document.getElementById('finalStage').style.display = isFinalStage ? 'block' : 'none';
      
      console.log(`Round ${currentRound}: ${round.name}, isBreak: ${isBreak}, isFinalStage: ${isFinalStage}`);
      
      // Update player table to reflect break/final stage
      if (tournamentStarted) {
        updatePlayerTable();
      }
    }

    function tick() {
      if (timeLeft > 0) {
        timeLeft--;
        document.getElementById('timeRemaining').textContent = formatTime(timeLeft);
      } else {
        // Time's up - auto advance to next round
        console.log('Timer finished, playing alarm...');
        clearInterval(timer);
        timerRunning = false;
        
        // Play alarm immediately
        playAlarm();
        
        // Show message and auto-advance after 3 seconds
        showMessage('‚è∞ ROUND FINISHED! Advancing to next round...');
        
        setTimeout(() => {
          nextRound();
        }, 3000);
      }
    }

    function startTimer() {
      if (!tournamentStarted || tournamentEnded || timerRunning) return;
      
      timerRunning = true;
      document.getElementById('timerStartBtn').disabled = true;
      document.getElementById('timerPauseBtn').disabled = false;
      
      timer = setInterval(tick, 1000);
      showMessage('Timer started');
    }

    function pauseTimer() {
      if (!timerRunning) return;
      
      clearInterval(timer);
      timerRunning = false;
      
      document.getElementById('timerStartBtn').disabled = false;
      document.getElementById('timerPauseBtn').disabled = true;
      
      showMessage('Timer paused');
    }

    function resetTimer() {
      clearInterval(timer);
      timerRunning = false;
      
      document.getElementById('timerStartBtn').disabled = false;
      document.getElementById('timerPauseBtn').disabled = true;
      
      updateRoundDisplay();
      showMessage('Timer reset');
    }

    function skipRound() {
      if (!tournamentStarted || tournamentEnded) return;
      
      clearInterval(timer);
      timerRunning = false;
      nextRound();
      showMessage('Round skipped');
    }

    function nextRound() {
      if (currentRound < rounds.length - 1) {
        currentRound++;
        updateRoundDisplay();
        
        // Auto-start next round if tournament is still active
        if (tournamentStarted && !tournamentEnded) {
          setTimeout(() => {
            startTimer();
          }, 1000); // Small delay to allow players to see the round change
        }
      } else {
        // Tournament structure complete
        showMessage('All rounds complete! Consider ending the tournament.');
      }
    }

    // Event handlers and initialization
    function setupEventHandlers() {
      const nameInput = document.getElementById('playerNameInput');
      const playerSelect = document.getElementById('playerSelect');
      
      if (nameInput) {
        nameInput.addEventListener('keydown', (event) => {
          if (event.key === 'Enter') {
            event.preventDefault();
            addPlayer();
          }
        });
      }
      
      if (playerSelect) {
        playerSelect.addEventListener('keydown', (event) => {
          if (event.key === 'Enter') {
            event.preventDefault();
            addPlayer();
          }
        });
        
        // When a player is selected, clear the input field
        playerSelect.addEventListener('change', () => {
          if (playerSelect.value) {
            nameInput.value = ''; // Clear the input if dropdown is selected
          }
        });
        
        // When input is typed, clear the dropdown selection
        nameInput.addEventListener('input', () => {
          if (nameInput.value) {
            playerSelect.value = ''; // Clear dropdown if typing in input
          }
        });
      }
    }

    // Initialize application
    function initializeApp() {
      console.log('Initializing app...');
      setupEventHandlers();
      updatePlayerTable();
      updateRoundDisplay();
      requestNotificationPermission();
      
      // Populate dropdown after a short delay to ensure DOM is ready
      setTimeout(() => {
        populatePlayerDropdown();
      }, 100);
      
      // Initialize Google API
      if (typeof gapi !== 'undefined') {
        handleClientLoad();
      } else {
        console.warn('Google API not available');
        showMessage('Google Sheets integration not available', true);
      }
      
      console.log('App initialized');
    }

    // Run initialization when page loads
    window.addEventListener('load', initializeApp);
    
    // Also run when DOM is ready (fallback)
    document.addEventListener('DOMContentLoaded', initializeApp);
  </script>
</body>
</html>